package sensoryCoding.network;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.List;

import org.ejml.simple.SimpleMatrix;

public class Network {
	// the given continuous time signal for which we are applying the gradient
	// descent
	public Signal thisSignal;
	// stores the differential of this signal
	public Signal differentialOfThisSignal;
	// the map that maps the spike timings to other properties
	// private Map<Integer, Integer> spikeIndexToKernelIndex = new HashMap<>();
	// this stores the list of kernel indexes generating the spikes in order
	public List<Integer> kernelIndexesForSpikes = new ArrayList<>();
	// this stores the list of spike indexes that each kernel generates
	public List<List<Integer>> spikeIndexesOfKernels = new ArrayList<>();
	// the map that maps the spike timings to the corresponding threshold value
	// that generated the spike
	// private Map<Integer, Double> spikeTimeToThresholdValue = new HashMap<>();
	// The sequence of time values when a spike is generated
	public List<Double> spikeTimings;
	// matrix that stores the inner product of kernels
	public double[][] pMatrix = null; // [numberofSpikes][numberofSpikes] Pij
										// is the inner product of kernels the
										// produce ith and jth spikes
	// shrunk P matrix with top N spikes
	public double[][] pMatrixWithNSpikes = null;
	// stores the inverse of the pMatrix
	public SimpleMatrix pInvMatrix = null;
	// stores the inverse of the pMatrix with top N spikes
	public SimpleMatrix pInvMatrixWithNSpikes = null;
	// this matrix stores the coefficients of the reconstructed signal
	public double[] coefficientsOfReconstructedSignal;
	// stores the coeffs due to top N spikes
	public double[] coefficientsOfReconstructedSignalWithNSpikes;
	// This matrix would store the differentials of spike timings wrt
	// coefficients of the kernels
	// i.e. (i,j)th entry denotes the differential of spike time ti w.r.t.
	// coefficient ki(b)j
	// which is the jth coeff. of kernel ki or the kernel generating ith spike
	public double timeDifferentials[][] = null;
	// This stores the reconstructed signal
	public Signal reconstructedSignal;
	// This stores the reconstructed signal with N spikes
	public Signal reconstructedSignalWithNSpikes;
	// This stores the differentials of the coefficients of reconstructed signal
	// w.r.t. components of the kernels
	public double coefficientDifferentials[][][] = null;
	// This stores the gradient values w.r.t. each kernel component
	public double errorGradients[][] = null;
	// kernel manager responsible for generating and calculating the kernels
	// values
	public KernelManager kernelMgr = null;
	// denotes the number of kernels present in the network
	private int numberOfKernels;
	// denotes the number of components each kernel in the network has
	private int numberofKernelComponents;
	// stores the values of convolving the signal with the kernels stored a
	// column vector
	public SimpleMatrix convolvedValuesMatrix;
	// stores the thresholds for top N spikes
	public SimpleMatrix convolvedValuesMatrixWithNSpikes;
	// This indicates the time when the network is initialized
	private long startTime;
	// This stores the list of all spike times generated by the kernel
	public List<List<Double>> kernelSpikeTimes;
	// This stores the list of total derivatives of spike times generated by the
	// kernel
	private List<List<List<Double>>> kernelSpikeTimeTotalDerivatives;
	// This is the list of kernels selected for this particular network
	private List<Integer> selectedKernelIndexes = new ArrayList<>();

	// stores the convolution of the signal with each kernel
	public Signal[] signalKernelConvolutionCache;

	// stores the spiking thresholds for each kernel with ahp into account
	public Signal[] kernelThresholds;

	public double[] thresholdForTesting = new double[ConfigurationParameters.lengthOfComponentSignals];

	// rate at which the coefficients need to be updated
	public static double LEARNING_RATE = ConfigurationParameters.INITIAL_LEARNING_RATE;
	// this specifies the threshold value of the gradient vector length beyond
	// which we tune the gradient values
	public static double THRESHOLD_GRADIENT_STEP_LENGTH = ConfigurationParameters.INITIAL_THRESHOLD_GRADIENT_STEP_LENGTH;
	// This array stores the average spike rate for each kernel
	public int[] totalSpikeCount = new int[ConfigurationParameters.numberOfKernels];
	// This array stores the average coefficient of reconstruction for each kernel
	public double[] averageCoefficientOfReConstruction = new double[ConfigurationParameters.numberOfKernels];
	// this 1XN matrix containing the thresholds for spike generation, N is the
	// number of spikes
	public double[][] convoledValues;
	// stores the reduced set of n threshold values
	public double[][] convolvedValuesWithNSpikes;
	// This stores the squared norm of the signal
	public double signalNormSquare = 0;

	/**
	 * Constructor that takes a signal piece as an argument
	 * 
	 * @param numberOfKernels
	 * @param numberofKernelComponents
	 * @throws Exception
	 */
	public Network(Signal signalPiece, int numberOfKernels, int numberofKernelComponents) throws Exception {
		startTime = System.currentTimeMillis();
		this.numberofKernelComponents = ConfigurationParameters.numberofKernelComponents;
		this.numberOfKernels = ConfigurationParameters.numberOfKernels;
		kernelMgr = new KernelManager(ConfigurationParameters.numberOfKernels,
				ConfigurationParameters.numberofKernelComponents, ConfigurationParameters.lengthOfComponentSignals);
		this.thisSignal = signalPiece;
		this.differentialOfThisSignal = SignalUtils.calculateSignalDifferential(thisSignal);
		initializeSignalToKernelCompConvolutions();
		selectAllKernels();
	}

	/**
	 * default constructor of the network
	 *
	 * @throws Exception
	 */
	public Network(Signal signalPiece) throws Exception {
		startTime = System.currentTimeMillis();
		this.numberofKernelComponents = ConfigurationParameters.numberofKernelComponents;
		this.numberOfKernels = ConfigurationParameters.numberOfKernels;
		kernelMgr = new KernelManager(ConfigurationParameters.numberOfKernels,
				ConfigurationParameters.numberofKernelComponents, ConfigurationParameters.lengthOfComponentSignals);
		this.thisSignal = signalPiece;
		selectAllKernels();
	}

	private void selectAllKernels() {
		// TODO Auto-generated method stub
		for (int i = 0; i < ConfigurationParameters.numberOfKernels; i++) {
			selectedKernelIndexes.add(i);
		}
	}

	/**
	 * default constructor of the network
	 *
	 * @throws Exception
	 */
	public Network(List<Integer> selectedKernels) throws Exception {
		this.numberofKernelComponents = ConfigurationParameters.numberofKernelComponents;
		this.numberOfKernels = ConfigurationParameters.numberOfKernels;
		kernelMgr = new KernelManager(ConfigurationParameters.numberOfKernels,
				ConfigurationParameters.numberofKernelComponents, ConfigurationParameters.lengthOfComponentSignals);
		this.selectedKernelIndexes = selectedKernels;
	}

	/**
	 * This method is invoked every time a new signal piece is injected
	 *
	 * @param signalPiece
	 * @throws Exception
	 */
	public void init(Signal signalPiece) throws Exception {
		init(signalPiece, true);
	}

	public void init(Signal signalPiece, boolean shouldUpdateSignalKernelCache) throws Exception {
		// TODO Auto-generated method stub
		// setting everything back to null
		this.thisSignal = signalPiece;
		this.signalNormSquare = SignalUtils.calculateSquaredNorm(signalPiece);
		if (shouldUpdateSignalKernelCache) {
			this.differentialOfThisSignal = SignalUtils.calculateSignalDifferential(thisSignal);
			this.signalDifferentialKernelComponentConvolutions = null;
			this.signalKernelComponentConvolutions = null;
			initializeSignalToKernelCompConvolutions();
		}
	}

	/**
	 * This method needs to invoked whenever we are loading data from file
	 *
	 * @param signalPiece
	 * @param differentialSignal
	 * @param signalKernelComponentConvolutions
	 * @param signalDifferentialKernelComponentConvolutions
	 * @throws Exception
	 */
	public void initFromFileData(Signal signalPiece, Signal differentialSignal,
			Signal[] signalKernelComponentConvolutions, Signal[] signalDifferentialKernelComponentConvolutions)
			throws Exception {
		// setting everything back to null
		this.coefficientDifferentials = null;
		this.coefficientsOfReconstructedSignal = null;
		this.convolvedValuesMatrix = null;
		this.differentialOfThisSignal = null;
		this.errorGradients = null;
		this.kernelIndexesForSpikes = new ArrayList<>();
		this.signalDifferentialKernelComponentConvolutions = null;
		this.signalKernelComponentConvolutions = null;
		this.signalKernelConvolutionCache = null;
		this.spikeTimings = null;
		this.thisSignal = null;
		this.kernelSpikeTimes = new ArrayList<List<Double>>();
		this.kernelSpikeTimeTotalDerivatives = new ArrayList<>();
		for (int i = 0; i < ConfigurationParameters.numberOfKernels; i++) {
			kernelSpikeTimes.add(new ArrayList<>());
			kernelSpikeTimeTotalDerivatives.add(new ArrayList<>());
			for (int c = 0; c < ConfigurationParameters.numberofKernelComponents; c++) {
				List<List<Double>> derivativeCompList = kernelSpikeTimeTotalDerivatives.get(i);
				derivativeCompList.add(new ArrayList<>());
			}
		}
		this.thisSignal = signalPiece;
		this.differentialOfThisSignal = differentialSignal;
		this.signalKernelComponentConvolutions = signalKernelComponentConvolutions;
		this.signalDifferentialKernelComponentConvolutions = signalDifferentialKernelComponentConvolutions;
	}

	/**
	 * This method needs to invoked whenever we are loading data from file
	 *
	 * @param signalPiece
	 * @param differentialSignal
	 * @param signalKernelComponentConvolutions
	 * @param signalDifferentialKernelComponentConvolutions
	 * @throws Exception
	 */
	public void initFromFileData(Signal signalPiece, Signal differentialSignal,
			Signal[] signalKernelComponentConvolutions) throws Exception {
		// setting everything back to null
		this.coefficientDifferentials = null;
		this.coefficientsOfReconstructedSignal = null;
		this.convolvedValuesMatrix = null;
		this.differentialOfThisSignal = null;
		this.errorGradients = null;
		this.kernelIndexesForSpikes = new ArrayList<>();

		this.signalDifferentialKernelComponentConvolutions = null;
		this.signalKernelComponentConvolutions = null;
		this.signalKernelConvolutionCache = null;
		this.spikeTimings = null;
		this.thisSignal = null;
		this.kernelSpikeTimes = new ArrayList<List<Double>>();
		this.kernelSpikeTimeTotalDerivatives = new ArrayList<>();
		for (int i = 0; i < ConfigurationParameters.numberOfKernels; i++) {
			kernelSpikeTimes.add(new ArrayList<>());
			kernelSpikeTimeTotalDerivatives.add(new ArrayList<>());
			for (int c = 0; c < ConfigurationParameters.numberofKernelComponents; c++) {
				List<List<Double>> derivativeCompList = kernelSpikeTimeTotalDerivatives.get(i);
				derivativeCompList.add(new ArrayList<>());
			}
		}
		this.thisSignal = signalPiece;
		this.differentialOfThisSignal = differentialSignal;
		this.signalKernelComponentConvolutions = signalKernelComponentConvolutions;
		signalDifferentialKernelComponentConvolutions = new Signal[numberOfKernels];
		for (int i = 0; i < ConfigurationParameters.numberOfKernels; i++) {
			signalDifferentialKernelComponentConvolutions[i] = populateKernelCompDiffConvolution(i);
		}
	}

	/**
	 * This function returns the error gradient matrix
	 *
	 * @return
	 */
	public double[][] getErrorGradients() {
		return errorGradients;
	}

	/**
	 * This function updates the kernel coefficients
	 *
	 * @throws Exception
	 */
	public double updateKernelCoefficients() throws Exception {
		double[][] updateOnKernelCoeffs = new double[ConfigurationParameters.numberOfKernels][ConfigurationParameters.numberofKernelComponents];
		if (errorGradients == null || errorGradients.length == 0) {
			return -1;
		}
		double squaredLengthOfGardient = 0;
		for (int i = 0; i < numberOfKernels; i++) {
			for (int j = 0; j < numberofKernelComponents; j++) {
				squaredLengthOfGardient += Math.pow(errorGradients[i][j], 2);
			}
		}

		// check if the step length exceeds the threshold
		boolean flag = false;
		double gardientLength = Math.sqrt(squaredLengthOfGardient);
		if (LEARNING_RATE * gardientLength > THRESHOLD_GRADIENT_STEP_LENGTH) {
			flag = true;
		}

		// calculate the coefficient update
		for (int i = 0; i < numberOfKernels; i++) {
			for (int j = 0; j < numberofKernelComponents; j++) {
				double increment = -LEARNING_RATE * errorGradients[i][j];
				if (flag) {
					increment = -(THRESHOLD_GRADIENT_STEP_LENGTH / gardientLength) * errorGradients[i][j];
				}
				updateOnKernelCoeffs[i][j] = increment;
			}
		}
		// current error rate
		double currentErrorRate = calculateErrorRate();
		System.out.println("error rate:" + currentErrorRate);
		kernelMgr.incrementKernelCoefficient(updateOnKernelCoeffs);

		// if the fail-safe mode is on check the validity of the update
		if (ConfigurationParameters.FAIL_SAFE_ON) {
			init(thisSignal, false);
			calculateSpikeTimesAndReconstructSignal();
			double nextError = calculateErrorRate();
			System.out.println("error in this step:" + currentErrorRate + "next error will be:" + nextError);
			if (currentErrorRate <= nextError) {
				// decrease all learning rates and stuff
				kernelMgr.rollBackUpdate(updateOnKernelCoeffs);
				if (ConfigurationParameters.LOCAL_MINIMA_MODE) {
					lowerLearningRates();
				}
				// kick out of local minima
				else {
					double[][] presentKernelCoeffs = kernelMgr.kernelCoefficients;
					for (int i = 0; i < ConfigurationParameters.NUMBER_OF_KICKS; i++) {
						double[][] newkernelCoeffs = new double[ConfigurationParameters.numberOfKernels][ConfigurationParameters.numberofKernelComponents];
						for (int k = 0; k < ConfigurationParameters.numberOfKernels; k++) {
							for (int c = 0; c < ConfigurationParameters.numberofKernelComponents; c++) {
								newkernelCoeffs[k][c] = presentKernelCoeffs[k][c] * (2 * Math.random() - 1);
							}
						}
						kernelMgr.initKernelCoefficients(newkernelCoeffs);
						init(thisSignal, false);
						calculateSpikeTimesAndReconstructSignal();
						if (currentErrorRate >= calculateErrorRate()) {
							System.out.println("got a kick here");
							break;
						} else {
							kernelMgr.initKernelCoefficients(presentKernelCoeffs);
						}
					}
				}
			} /*
				 * else{ // bring back original learning rates restoreLearningRates(); }
				 */
		}
		return currentErrorRate;
	}

	/**
	 * Lower the learning rates
	 */
	private void lowerLearningRates() {
		// TODO Auto-generated method stub
		THRESHOLD_GRADIENT_STEP_LENGTH /= 10;
		LEARNING_RATE /= 10;
	}

	/**
	 * Increase the learning rate to kick out of the local minima
	 */
	private void increaseLearningRates() {
		THRESHOLD_GRADIENT_STEP_LENGTH *= 10;
		LEARNING_RATE *= 10;
	}

	/**
	 * bring back the original learning rates
	 */
	private void restoreLearningRates() {
		THRESHOLD_GRADIENT_STEP_LENGTH = ConfigurationParameters.INITIAL_THRESHOLD_GRADIENT_STEP_LENGTH;
		LEARNING_RATE *= ConfigurationParameters.INITIAL_LEARNING_RATE;
	}

	/**
	 * This function is used to update any statistics that we are interested in
	 * collecting from the network
	 *
	 * @param stepNumber
	 */
	public void UpdateStatistics(int stepNumber) {
		reconstructedSignal.saveSignalIntoFile("Reconstructed Signal after" + stepNumber + "steps",
				ConfigurationParameters.SIGNAL_IMAGE_FILE_NAME + stepNumber + ".png");
		Utilities.writeMatrixToFile("Error gradients after" + stepNumber + "steps",
				ConfigurationParameters.ERRORGRAD_LOG_FILE_NAME + stepNumber, errorGradients);
		Utilities.writeMatrixToFile("Kernel Coefficients after" + stepNumber + "steps",
				ConfigurationParameters.KERNELCOEFF_LOG_FILE_NAME + stepNumber, kernelMgr.kernelCoefficients);
		System.out.println("Time taken to till" + stepNumber + "steps:" + (System.currentTimeMillis() - startTime));
		System.out.println("The spike timings are as follows");
		for (int i = 0; i < spikeTimings.size(); i++) {
			System.out.print(spikeTimings.get(i));
			System.out.print(",");
		}
		System.out.println("Error due to reconstruction: " + calculateError());
		System.out.println("updated coefficient: " + kernelMgr.kernelCoefficients[0][0]);
	}

	/**
	 * This method saves the current state of the network into a file
	 *
	 * @param stepNumber
	 * @throws IOException
	 */
	public void saveNetworkState(int stepNumber) throws IOException {
		FileWriter fw = new FileWriter(ConfigurationParameters.STATE_OF_NETWORK);
		BufferedWriter bw = new BufferedWriter(fw);
		bw.write(Integer.toString(stepNumber));
		bw.write("\n");
		Utilities.writeMatrixToBufferedWriter(bw, kernelMgr.kernelCoefficients);
		bw.close();
	}

	/**
	 * This method retrieves the last state of the network from a file and returns
	 * the number of already executed steps
	 *
	 * @return
	 * @throws NumberFormatException
	 * @throws IOException
	 */
	public int restoreNetworkState() throws NumberFormatException, IOException {
		FileReader fr = new FileReader(ConfigurationParameters.STATE_OF_NETWORK);
		BufferedReader br = new BufferedReader(fr);
		int stepNumber = Integer.parseInt(br.readLine());
		double[][] kernelCoefficients = Utilities.readMatrixToBufferedWriter(br);
		br.close();
		kernelMgr.kernelCoefficients = kernelCoefficients;
		return stepNumber;
	}

	/**
	 * This method computes the reconstructed signal and runs a single step gradient
	 * descent on the coefficients of the kernels
	 *
	 * @throws Exception
	 */
	public void reconstructAndUpdateKernels() throws Exception {

		this.calculateSpikeTimings();
		// if there is no spike generated just get out of the method
		if (this.spikeTimings.size() == 0) {
			return;
		}
		this.calculatePMatrix(); // well tested
		this.calculateTheCoefficientsOfReconstructedKernel(); // well tested
	}

	/**
	 * This method computes the gradient wrt kernel coefficients
	 *
	 * @throws Exception
	 */
	public void calculateErrorGradient() throws Exception {
		// if there is no spike generated just get out of the method
		if (this.spikeTimings.size() == 0) {
			return;
		}
		long t1 = System.currentTimeMillis();
		// first compute the time differentials
		this.calculateTimeDifferentials();

		// next compute the time error differentials
		long t2 = System.currentTimeMillis();
		if (ConfigurationParameters.USER_MODE.equals(MODE.DEBUG_MODE))
			System.out.println("time to calculate time differentials:" + (t2 - t1) + "ms");
		this.calculateErrorDifferential();
		long t4 = System.currentTimeMillis();
		if (ConfigurationParameters.USER_MODE.equals(MODE.DEBUG_MODE))
			System.out.println("time to calculate error gradients:" + (t4 - t2) + "ms");
	}

	/**
	 * This method calculates the spike times and returns the reconstructed signal
	 *
	 * @return
	 * @throws Exception
	 */
	public void calculateSpikeTimesAndReconstructSignal() throws Exception {
		calculateSpikeTimings();
		// if there is no spike generated just get out of the method
		if (this.spikeTimings.size() == 0) {
			return;
		}
		System.out.println("number of generated spikes:" + spikeTimings.size());
		reconstructSignal();
	}

	@Deprecated
	/**
	 * a stopgap solution added for dealing with reconstruction ignoring certain
	 * spikes
	 */
	public void removeSpikes(List<Integer> indexestoBeRemoved) {
		double[][] newConvolvedValues = new double[1][spikeTimings.size() - indexestoBeRemoved.size()];
		int newArrayIndex = newConvolvedValues[0].length - 1;
		for (int i = spikeTimings.size() - 1; i >= 0; i--) {
			if (indexestoBeRemoved.contains(i)) {
				spikeTimings.remove(i);
				kernelIndexesForSpikes.remove(i);
			} else {
				// populate the threshold matrix
				newConvolvedValues[0][newArrayIndex] = convoledValues[0][i];
				newArrayIndex--;
			}
		}
		convolvedValuesMatrix = new SimpleMatrix(newConvolvedValues).transpose();
	}

	/**
	 * Given the spike times reconstruct the signal
	 * 
	 * @throws Exception
	 */
	private void reconstructSignal() throws Exception {
		calculateCoefficientsAndInitSpikeComparator();
		if (ConfigurationParameters.SHOULD_COLLECT_SPIKE_STATISTICS) {
			populateSpikeStatistics();
		}
	}

	private SpikeIndexComparator2 spikeComparator = null;
	//private SpikeIndexComparator spikeComparator = null;
	/**
	 * Reconstructs the signal using top n spikes prioritized based on their
	 * coefficients
	 * 
	 * @param n
	 * @throws Exception
	 */
	public void reconstructSignalWithNSpikes(int n) throws Exception {
		//TODO: for spike comparator1 comment it out
		Arrays.sort(spikeComparator.indexes,0,n+1, spikeComparator);
		calculatePMatrixWithNSpikes(n);
		calculateTheCoefficientsOfReconstructedKernelWithNSpikes(n);
		//TODO: for spike comparator1 comment it out
		spikeComparator.updateCoefficients(coefficientsOfReconstructedSignalWithNSpikes, n);		
	}

	/**
	 * This method computes the coefficients of the reconstructed signal and sorts
	 * the spike indexes based on these coefficients
	 * 
	 * @throws Exception
	 */
	private void calculateCoefficientsAndInitSpikeComparator() throws Exception {
		calculatePMatrix();
		calculateTheCoefficientsOfReconstructedKernel();
		spikeComparator = new SpikeIndexComparator2(coefficientsOfReconstructedSignal, convoledValues[0]);
		//spikeComparator = new SpikeIndexComparator(coefficientsOfReconstructedSignal, convoledValues[0]);
		spikeComparator.createIndexArray();
		Arrays.sort(spikeComparator.indexes, spikeComparator);
	}

	/**
	 * This method calculates the coefficients of the reconstructed signal when top
	 * n spikes are used
	 * 
	 * @param n
	 */
	private void calculateTheCoefficientsOfReconstructedKernelWithNSpikes(int n) {
		// TODO Auto-generated method stub
		Integer[] sortedIndexes = spikeComparator.indexes;
		convolvedValuesWithNSpikes = new double[1][n];
		for (int i = 0; i < n; i++) {
			int indexi = sortedIndexes[i];
			convolvedValuesWithNSpikes[0][i] = convoledValues[0][indexi];
		}
		convolvedValuesMatrixWithNSpikes = new SimpleMatrix(convolvedValuesWithNSpikes).transpose();
		coefficientsOfReconstructedSignalWithNSpikes = new double[n];
		coefficientsOfReconstructedSignalWithNSpikes = Utilities
				.getArrayFromMatrix((pInvMatrixWithNSpikes.mult(convolvedValuesMatrixWithNSpikes)).transpose())[0];
	}

	/**
	 * Calculates the reduced pMatrix that takes only n spikes into consideration
	 * 
	 * @param n
	 * @throws Exception
	 */
	private void calculatePMatrixWithNSpikes(int n) throws Exception {
		pMatrixWithNSpikes = new double[n][n];
		Integer[] sortedIndexes = spikeComparator.indexes;
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < n; j++) {
				int indexi = sortedIndexes[i];
				int indexj = sortedIndexes[j];
				pMatrixWithNSpikes[i][j] = pMatrix[indexi][indexj];//calculatePij(indexi, indexj);
			}
		}
		pInvMatrixWithNSpikes = new SimpleMatrix(pMatrixWithNSpikes).invert();

	}

	private void populateSpikeStatistics() {
		// TODO Auto-generated method stub
		double[] sumOfCoefficientsOfReconstructedKernel = new double[ConfigurationParameters.numberOfKernels];
		for (int i = 0; i < coefficientsOfReconstructedSignal.length; i++) {
			int kernelIndex = kernelIndexesForSpikes.get(i);
			double coeff = coefficientsOfReconstructedSignal[i];
			sumOfCoefficientsOfReconstructedKernel[kernelIndex] += coeff;
		}

		for (int i = 0; i < ConfigurationParameters.numberOfKernels; i++) {
			int initialSpikeCount = totalSpikeCount[i];
			int updatedSpikeCount = initialSpikeCount + kernelSpikeTimes.get(i).size();
			if (updatedSpikeCount != 0) {
				averageCoefficientOfReConstruction[i] = (averageCoefficientOfReConstruction[i] * initialSpikeCount
						+ sumOfCoefficientsOfReconstructedKernel[i]) / updatedSpikeCount;
			}
			totalSpikeCount[i] = updatedSpikeCount;
		}
	}

	/**
	 * Gets the indexes of all the spikes generated by this kernel
	 *
	 * @return
	 */
	public List<Integer> GetAllSpikesGeneratedByThisKernel(int kernelIndex) {
		List<Integer> generatedSpikeIndexes = new ArrayList<>();
		for (int i = 0; i < spikeTimings.size(); i++) {
			if (kernelIndexesForSpikes.get(i).equals(kernelIndex)) {
				generatedSpikeIndexes.add(i);
			}
		}
		return generatedSpikeIndexes;
	}

	/**
	 * This method returns the reconstructed signal from the input signal
	 *
	 * @return
	 * @throws Exception
	 */
	@Deprecated
	public Signal getReconstructedSignalInaccurate() throws Exception {
		/**
		 * Commenting the redundant step
		 */
		// kernelMgr.loadTimeInvertedKernelCache();
		Signal resultingReconstruction = new Signal(new double[thisSignal.getLength()], 0, 0);
		for (int i = 0; i < spikeTimings.size(); i++) {
			resultingReconstruction = SignalUtils.addTwoSignals(resultingReconstruction,
					SignalUtils.scalarMultiply(
							SignalUtils.shiftSignal(kernelMgr.getInvertedKernel(kernelIndexesForSpikes.get(i)),
									spikeTimings.get(i)),
							coefficientsOfReconstructedSignal[i]));
		}
		this.reconstructedSignal = resultingReconstruction;
		return this.reconstructedSignal;
	}

	/**
	 * This method returns the reconstructed signal from the input signal
	 *
	 * @return
	 * @throws Exception
	 */
	public Signal getReconstructedSignal() throws Exception {
		List<Signal> components = new ArrayList<>();
		for (int i = 0; i < spikeTimings.size(); i++) {
			Signal comp = SignalUtils.scalarMultiply(SignalUtils
					.shiftSignal(kernelMgr.getInvertedKernel(kernelIndexesForSpikes.get(i)), spikeTimings.get(i)),
					coefficientsOfReconstructedSignal[i]);
			components.add(comp);
		}
		this.reconstructedSignal = SignalUtils.addNSignals(components);
		return this.reconstructedSignal;

	}

	/**
	 * This method returns the reconstructed signal from the input signal with N
	 * spikes
	 *
	 * @return
	 * @throws Exception
	 */
	public Signal getReconstructedSignalWithNSpikes() throws Exception {
		List<Signal> components = new ArrayList<>();
		Integer[] sortedIndexes = spikeComparator.indexes;
		for (int i = 0; i < coefficientsOfReconstructedSignalWithNSpikes.length; i++) {
			Signal comp = SignalUtils.scalarMultiply(
					SignalUtils.shiftSignal(kernelMgr.getInvertedKernel(kernelIndexesForSpikes.get(sortedIndexes[i])),
							spikeTimings.get(sortedIndexes[i])),
					coefficientsOfReconstructedSignalWithNSpikes[i]);
			components.add(comp);
		}
		this.reconstructedSignalWithNSpikes = SignalUtils.addNSignals(components);
		return this.reconstructedSignalWithNSpikes;
	}

	/**
	 * This method computes the coefficients of the reconstructed kernel
	 */
	private void calculateTheCoefficientsOfReconstructedKernel() {
		coefficientsOfReconstructedSignal = new double[spikeTimings.size()];
		coefficientsOfReconstructedSignal = Utilities
				.getArrayFromMatrix((pInvMatrix.mult(convolvedValuesMatrix)).transpose())[0];
	}

	/**
	 * This method calculates the P matrix or the kernel product matrix
	 *
	 * @throws Exception
	 */
	private void calculatePMatrix() throws Exception {
		// TODO Auto-generated method stub
		pMatrix = new double[spikeTimings.size()][spikeTimings.size()];
		for (int i = 0; i < spikeTimings.size(); i++) {
			for (int j = 0; j < spikeTimings.size(); j++) {
				pMatrix[i][j] = calculatePij(i, j);
			}
		}
		pInvMatrix = new SimpleMatrix(pMatrix).invert();

	}

	// Verified
	/**
	 * This method calculates each entry in the PMatrix
	 *
	 * @param i
	 * @param j
	 * @return
	 * @throws Exception
	 */
	private double calculatePij(int i, int j) throws Exception {
		int kernelIndexI = kernelIndexesForSpikes.get(i);
		int kernelIndexJ = kernelIndexesForSpikes.get(j);
		double timeShiftOfI = spikeTimings.get(i);
		double timeShiftOfJ = spikeTimings.get(j);
		double total = 0;
		for (int c1 = 0; c1 < numberofKernelComponents; c1++) {
			double betac1 = kernelMgr.kernelCoefficients[kernelIndexI][c1];
			for (int c2 = 0; c2 < numberofKernelComponents; c2++) {
				double betac2 = kernelMgr.kernelCoefficients[kernelIndexJ][c2];
				total += betac1 * betac2
						* kernelMgr.getCompByCompMult(kernelIndexI, kernelIndexJ, c1, c2, timeShiftOfI, timeShiftOfJ);
			}
		}
		return total;
	}

	/**
	 * This method computes the spike timings
	 *
	 * @throws Exception
	 */
	private void calculateSpikeTimings() throws Exception {
		spikeComparator = null;
		signalKernelConvolutionCache = new Signal[numberOfKernels];
		kernelThresholds = new Signal[numberOfKernels];
		List<SpikeTimeIndexAndConvolvedValues> spikeTimes = new ArrayList<>();

		/**
		 * This part is to initialize the data structure for storing the spike times of
		 * a kernel
		 */
		this.kernelSpikeTimes = new ArrayList<List<Double>>();
		for (int i = 0; i < ConfigurationParameters.numberOfKernels; i++) {
			kernelSpikeTimes.add(new ArrayList<>());
		}
		// generate spikes for each kernel iteratively and can be parallelized
		for (int kernelIndexer = 0; kernelIndexer < selectedKernelIndexes.size(); kernelIndexer++) {
			// for (int i = 0; i < numberOfKernels; i++) {
			int i = selectedKernelIndexes.get(kernelIndexer);
			double[] convolvedSignal = new double[thisSignal.getLength()];
			for (int j = 0; j < thisSignal.getLength(); j++)
				for (int k = 0; k < numberofKernelComponents; k++) {
					convolvedSignal[j] += kernelMgr.kernelCoefficients[i][k] * getSignalKernelCompConvolution(i, k, j);
				}
			signalKernelConvolutionCache[i] = new Signal(convolvedSignal);
			List<SpikeTimeIndexAndConvolvedValues> allSpikes = null;
			if (!DebugConfigurationParameters.SHOULD_USE_ACCURATES) {
				allSpikes = generateSpikes(convolvedSignal, i);
			} else {
				allSpikes = generateSpikesAccurately(convolvedSignal, i);
			}
			spikeTimes.addAll(allSpikes);
		}

		spikeTimes.sort(new Comparator<SpikeTimeIndexAndConvolvedValues>() {

			@Override
			public int compare(SpikeTimeIndexAndConvolvedValues o1, SpikeTimeIndexAndConvolvedValues o2) {
				if (o1.spikeTime == o2.spikeTime) {
					return 0;
				} else if (o1.spikeTime < o2.spikeTime) {
					return -1;
				}
				return 1;
			}
		});
		this.spikeTimings = new ArrayList<>();
		spikeIndexesOfKernels = new ArrayList<>();
		kernelIndexesForSpikes = new ArrayList<>();
		// Initialize the structure for storing spike indexes for each kernel
		for (int i = 0; i < ConfigurationParameters.numberOfKernels; i++) {
			spikeIndexesOfKernels.add(new ArrayList<Integer>());
		}
		// this.spikeIndexToKernelIndex = new HashMap<>();
		convoledValues = new double[1][spikeTimes.size()];
		for (int i = 0; i < spikeTimes.size(); i++) {
			SpikeTimeIndexAndConvolvedValues thisSpike = spikeTimes.get(i);
			spikeTimings.add(thisSpike.spikeTime);
			convoledValues[0][i] = thisSpike.convolvedValue;
			// spikeIndexToKernelIndex.put(i, thisSpike.kernelIndex);
			kernelIndexesForSpikes.add(thisSpike.kernelIndex);
			spikeIndexesOfKernels.get(thisSpike.kernelIndex).add(i);
		}

		convolvedValuesMatrix = new SimpleMatrix(convoledValues).transpose();
	}

	/**
	 *
	 * @param convolvedSignal
	 * @param kernelIndex
	 * @return
	 */
	private List<SpikeTimeIndexAndConvolvedValues> generateSpikes(double[] convolvedSignal, int kernelIndex) {
		List<SpikeTimeIndexAndConvolvedValues> generatedSpikes = new ArrayList<>();
		double[] thresholdValues = new double[convolvedSignal.length];
		// TODO: at t=0 we are not generating any spikes
		for (int l = 1; l < convolvedSignal.length; l++) {
			double threshold = getThreshold(kernelIndex, l);

			if (convolvedSignal[l] > threshold) {
				if (kernelIndex == 0) {
					System.out.println("This is explicitly for debugging");
				}
				double deltaThreshold = getThreshold(kernelIndex, l) - getThreshold(kernelIndex, l - 1);
				double deltaSignal = convolvedSignal[l] - convolvedSignal[l - 1];
				double deltaTime = (getThreshold(kernelIndex, l - 1) - convolvedSignal[l - 1])
						/ (deltaSignal - deltaThreshold);
				if (deltaTime > 1 || deltaTime < 0) {
					throw new IllegalArgumentException("delta time has invalid value:" + deltaTime + "," + threshold
							+ "," + getThreshold(kernelIndex, l - 1) + "," + convolvedSignal[l] + ","
							+ convolvedSignal[l - 1]);
				}
				double updatedThreshold = convolvedSignal[l - 1]
						+ deltaTime * (convolvedSignal[l] - convolvedSignal[l - 1]);
				double thisSpikeTime = (l - 1 + deltaTime) * ((double) ConfigurationParameters.TIME_STEP);
				generatedSpikes.add(new SpikeTimeIndexAndConvolvedValues(thisSpikeTime, kernelIndex, updatedThreshold));
				List<Double> spikeTimes = kernelSpikeTimes.get(kernelIndex);
				spikeTimes.add(thisSpikeTime);
			}
			thresholdValues[l] = getThreshold(kernelIndex, l);
			thresholdForTesting[l] = threshold;
		}
		kernelThresholds[kernelIndex] = new Signal(thresholdValues);
		if (DebugConfigurationParameters.DEBUG_MODE_ON
				&& DebugConfigurationParameters.TEST_KERNEL_INDEX == kernelIndex) {
			Signal[] debugSignals = new Signal[2];
			debugSignals[0] = (new Signal(convolvedSignal));
			debugSignals[1] = (new Signal(thresholdValues));
			// Utilities.displaySetOfSignals(debugSignals, "Convolution and Threshold values
			// for kernel#" + kernelIndex,0,1000);
			debugSignals[0].DrawSignal("before change", 50, 100);
		}
		return generatedSpikes;
	}

	/**
	 * This method produces spikes in the exact time regardless the ahp slope
	 * 
	 * @param convolvedSignal
	 * @param kernelIndex
	 * @return
	 */
	private List<SpikeTimeIndexAndConvolvedValues> generateSpikesAccurately(double[] convolvedSignal, int kernelIndex) {
		List<SpikeTimeIndexAndConvolvedValues> generatedSpikes = new ArrayList<>();
		double[] thresholdValues = new double[convolvedSignal.length];
		// TODO: at t=0 we are not generating any spikes
		double lastSpikeTime = -1;
		for (int l = 1; l < convolvedSignal.length; l++) {
			double threshold = getThreshold(kernelIndex, l);
			if (convolvedSignal[l] > threshold) {
				double deltaSignal = convolvedSignal[l] - convolvedSignal[l - 1];
				double deltaTime = 0;
				double actualThreshold = 0;
				/**
				 * There are two cases
				 */
				// case 1: when the threshold is constant
				if (lastSpikeTime == -1 || (l - 1 - lastSpikeTime) > ConfigurationParameters.AHP_REFRACTORY_PERIOD) {
					deltaTime = (ConfigurationParameters.initialThresHoldValue - convolvedSignal[l - 1]) / deltaSignal;
					actualThreshold = ConfigurationParameters.initialThresHoldValue;
				}
				// case 2: when the threshold itself is going down and ahp effect stops beyond l
				else if ((l - lastSpikeTime) <= ConfigurationParameters.AHP_REFRACTORY_PERIOD) {
					deltaTime = (getThreshold(kernelIndex, l - 1) - convolvedSignal[l - 1])
							/ (deltaSignal + ConfigurationParameters.AHP_SLOPE);
					actualThreshold = deltaTime * deltaSignal + convolvedSignal[l - 1];
				}
				// case 3: when the threshold itself is going down and ahp effect stops in the
				// middle
				else if ((l - 1 - lastSpikeTime) < ConfigurationParameters.AHP_REFRACTORY_PERIOD
						&& (l - lastSpikeTime) > ConfigurationParameters.AHP_REFRACTORY_PERIOD) {
					/**
					 * This has two sub-cases in it
					 */
					double convolvedValueAtCeasePoint = convolvedSignal[l - 1]
							+ (deltaSignal) * (lastSpikeTime + ConfigurationParameters.AHP_REFRACTORY_PERIOD - l + 1);
					// case a. when the threshold crossing happens after ahp effect ceases
					if (convolvedValueAtCeasePoint <= ConfigurationParameters.initialThresHoldValue) {
						deltaTime = (ConfigurationParameters.initialThresHoldValue - convolvedSignal[l - 1])
								/ deltaSignal;
						actualThreshold = ConfigurationParameters.initialThresHoldValue;
					}
					// case b. when the threshold crossing happens before the ahp effect ceases
					else if (convolvedValueAtCeasePoint > ConfigurationParameters.initialThresHoldValue) {
						deltaTime = (getThreshold(kernelIndex, l - 1) - convolvedSignal[l - 1])
								/ (deltaSignal + ConfigurationParameters.AHP_SLOPE);
						actualThreshold = deltaTime * deltaSignal + convolvedSignal[l - 1];
					} else {
						throw new IllegalArgumentException(
								"Something wrong in spike generation: something weird came up");
					}
				} else {
					throw new IllegalArgumentException(
							"Could not decide how to handle this particular case for spike generation");
				}
				if (deltaTime > 1 || deltaTime < 0) {
					throw new IllegalArgumentException("delta time has invalid value:" + deltaTime + "," + threshold
							+ "," + getThreshold(kernelIndex, l - 1) + "," + convolvedSignal[l] + ","
							+ convolvedSignal[l - 1]);
				}
				double updatedThreshold = actualThreshold;
				double thisSpikeTime = (l - 1 + deltaTime) * ((double) ConfigurationParameters.TIME_STEP);
				generatedSpikes.add(new SpikeTimeIndexAndConvolvedValues(thisSpikeTime, kernelIndex, updatedThreshold));
				List<Double> spikeTimes = kernelSpikeTimes.get(kernelIndex);
				spikeTimes.add(thisSpikeTime);
				lastSpikeTime = thisSpikeTime;
			}
			thresholdValues[l] = getThreshold(kernelIndex, l);
			thresholdForTesting[l] = threshold;
		}
		kernelThresholds[kernelIndex] = new Signal(thresholdValues);
		if (DebugConfigurationParameters.DEBUG_MODE_ON
				&& DebugConfigurationParameters.TEST_KERNEL_INDEX == kernelIndex) {
			Signal[] debugSignals = new Signal[2];
			debugSignals[0] = (new Signal(convolvedSignal));
			debugSignals[1] = (new Signal(thresholdValues));
			Utilities.displaySetOfSignals(debugSignals, "Convolution and Threshold values for kernel#" + kernelIndex, 0,
					1000);
			debugSignals[0].DrawSignal("before change", 50, 100);
		}
		return generatedSpikes;
	}

	/**
	 * This method returns the threshold value for a given kernel at a particular
	 * time instance
	 *
	 * @param kernelIndex
	 * @param time
	 * @return
	 */
	private double getThreshold(int kernelIndex, int time) {
		return kernelMgr.getThreshold(kernelIndex, time) + getLinearAhpForThisKernel(kernelIndex, time);
	}

	@Deprecated
	private double getAhpForThisKernel(int kernelIndex, int time) {
		// TODO Auto-generated method stub
		List<Double> thisKernelSpikes = kernelSpikeTimes.get(kernelIndex);
		double total = 0;
		for (int i = thisKernelSpikes.size() - 1; i >= 0; i--) {
			total += (ConfigurationParameters.AHP_CONSTANT)
					* Math.exp(-(time - thisKernelSpikes.get(i)) / ConfigurationParameters.TIME_CONSTANT);
		}
		return total;
	}

	/**
	 * This function returns the linear ahp value for the kernel
	 * 
	 * @param kernelIndex
	 * @param time
	 * @return
	 */
	private double getLinearAhpForThisKernel(int kernelIndex, int time) {
		// TODO Auto-generated method stub
		List<Double> thisKernelSpikes = kernelSpikeTimes.get(kernelIndex);
		if (thisKernelSpikes.size() == 0) {
			return 0;
		}
		double lastSpikeTime = thisKernelSpikes.get(thisKernelSpikes.size() - 1);
		if (time - lastSpikeTime > ConfigurationParameters.AHP_REFRACTORY_PERIOD) {
			return 0;
		} else {
			double M = ConfigurationParameters.AHP_HIGH_VALUE;
			return M - M * (time - lastSpikeTime) / ConfigurationParameters.AHP_REFRACTORY_PERIOD;
		}
	}

	/**
	 * This function returns the differential of the ahp function
	 *
	 * @param timeDiff
	 * @return
	 */
	private double getAhpDifferential(double timeDiff) {
		return -ConfigurationParameters.AHP_CONSTANT * (Math.exp(-(timeDiff / ConfigurationParameters.TIME_CONSTANT))
				/ ConfigurationParameters.TIME_CONSTANT);
	}

	/**
	 * This method computes the differentials of the spike times wrt kernel
	 * coefficients
	 *
	 * @throws Exception
	 */
	public void calculateTimeDifferentials() throws Exception {
		/**
		 * This part is to initialize the data structure that stores the kernel spike
		 * time differentials
		 */
		this.kernelSpikeTimeTotalDerivatives = new ArrayList<List<List<Double>>>();
		for (int i = 0; i < ConfigurationParameters.numberOfKernels; i++) {
			kernelSpikeTimeTotalDerivatives.add(new ArrayList<>());
			for (int c = 0; c < ConfigurationParameters.numberofKernelComponents; c++) {
				List<List<Double>> derivativeCompList = kernelSpikeTimeTotalDerivatives.get(i);
				derivativeCompList.add(new ArrayList<Double>());
			}
		}
		/**
		 * Do the actual dt/db computations here
		 */
		timeDifferentials = new double[spikeTimings.size()][numberofKernelComponents];
		for (int i = 0; i < timeDifferentials.length; i++) {
			for (int j = 0; j < numberofKernelComponents; j++) {
				calculateSingleTimeDifferentialWithLinearAhp(i, j);
			}
		}
	}

	/*************************************/
	/******** impl1 commented out **********/
	/*************************************/
	/*	*//**
			 * This method calculates the differential of the ith spike timing w.r.t. jth
			 * coeff. of the kernel generating the spike
			 *
			 * @param thisSpikeTimeIndex
			 * @param thisKernelComponentIndex
			 * @throws Exception
			 *//*
				 * private void calculateSingleTimeDifferential(int thisSpikeTimeIndex, int
				 * thisKernelComponentIndex) throws Exception { if(thisSpikeTimeIndex == 13){
				 * System.out.println("come here"); } double spikeTime =
				 * spikeTimings.get(thisSpikeTimeIndex); int thisKernelIndex =
				 * kernelIndexesForSpikes.get(thisSpikeTimeIndex); // TODO: this can be improved
				 * in performance // calculate the numerator double numerator =
				 * -getSignalKernelCompConvolution(thisKernelIndex, thisKernelComponentIndex,
				 * spikeTime); double denominator =
				 * (signalKernelConvolutionCache[thisKernelIndex].getSignalValue( spikeTime + 1)
				 * - signalKernelConvolutionCache[thisKernelIndex].getSignalValue( spikeTime)) /
				 * ConfigurationParameters.TIME_STEP;
				 *
				 * double denominatorForParital = denominator; List<Double> totalTimeDerivatives
				 * = kernelSpikeTimeTotalDerivatives.get(thisKernelIndex).get(
				 * thisKernelComponentIndex); List<Double> thisKernelSpikeTimes =
				 * kernelSpikeTimes.get(thisKernelIndex); for(int i=
				 * totalTimeDerivatives.size()-1; i>=0; i--){ denominatorForParital -=
				 * getAhpDifferential(spikeTime- thisKernelSpikeTimes.get(i)); }
				 *
				 * double partialTimeDiff = numerator/denominatorForParital;
				 *
				 * double totalTimeDiff = partialTimeDiff; for(int i=
				 * totalTimeDerivatives.size()-1; i>=0; i--){ double
				 * partialTimeDiffForThisPrevSpike = (- getAhpDifferential(spikeTime-
				 * thisKernelSpikeTimes.get(i)))/(denominator); totalTimeDiff +=
				 * totalTimeDerivatives.get(i)*partialTimeDiffForThisPrevSpike; }
				 *
				 * timeDifferentials[thisSpikeTimeIndex][thisKernelComponentIndex] =
				 * totalTimeDiff; totalTimeDerivatives.add(totalTimeDiff); }
				 */

	/*************************************/
	/******** impl2 in use for now *********/
	/*************************************/
	private void calculateSingleTimeDifferential(int thisSpikeTimeIndex, int thisKernelComponentIndex)
			throws Exception {
		double spikeTime = spikeTimings.get(thisSpikeTimeIndex);
		int thisKernelIndex = kernelIndexesForSpikes.get(thisSpikeTimeIndex);
		// TODO: this can be improved in performance
		// calculate the numerator
		double numerator = -getSignalKernelCompConvolution(thisKernelIndex, thisKernelComponentIndex, spikeTime);
		double denominator = (signalKernelConvolutionCache[thisKernelIndex].getSignalValue(spikeTime + 1)
				- signalKernelConvolutionCache[thisKernelIndex].getSignalValue(spikeTime))
				/ ConfigurationParameters.TIME_STEP;

		double denominatorForTotalDerivative = denominator;
		double numeratorForTotalDerivative = numerator;
		List<Double> totalTimeDerivatives = kernelSpikeTimeTotalDerivatives.get(thisKernelIndex)
				.get(thisKernelComponentIndex);
		List<Double> thisKernelSpikeTimes = kernelSpikeTimes.get(thisKernelIndex);
		for (int i = totalTimeDerivatives.size() - 1; i >= 0; i--) {
			denominatorForTotalDerivative -= getAhpDifferential(spikeTime - thisKernelSpikeTimes.get(i));
			numeratorForTotalDerivative -= getAhpDifferential(spikeTime - thisKernelSpikeTimes.get(i))
					* totalTimeDerivatives.get(i);
		}
		double totalDiff = numeratorForTotalDerivative / denominatorForTotalDerivative;
		timeDifferentials[thisSpikeTimeIndex][thisKernelComponentIndex] = totalDiff;
		totalTimeDerivatives.add(totalDiff);
	}

	/*************************************/
	/***** impl with linear ahp in use ***/
	/*************************************/
	private void calculateSingleTimeDifferentialWithLinearAhp(int thisSpikeTimeIndex, int thisKernelComponentIndex)
			throws Exception {
		double spikeTime = spikeTimings.get(thisSpikeTimeIndex);
		int thisKernelIndex = kernelIndexesForSpikes.get(thisSpikeTimeIndex);
		// TODO: this can be improved in performance
		// calculate the numerator
		double numerator = -getSignalKernelCompConvolution(thisKernelIndex, thisKernelComponentIndex, spikeTime);
		double denominator = (signalKernelConvolutionCache[thisKernelIndex].getSignalValue(spikeTime + 1)
				- signalKernelConvolutionCache[thisKernelIndex].getSignalValue(spikeTime))
				/ ConfigurationParameters.TIME_STEP;

		double denominatorForTotalDerivative = denominator;
		double numeratorForTotalDerivative = numerator;
		List<Double> totalTimeDerivatives = kernelSpikeTimeTotalDerivatives.get(thisKernelIndex)
				.get(thisKernelComponentIndex);
		List<Double> thisKernelSpikeTimes = kernelSpikeTimes.get(thisKernelIndex);
		double c = ConfigurationParameters.AHP_SLOPE;
		if (totalTimeDerivatives.size() > 0 && (spikeTime - thisKernelSpikeTimes
				.get(totalTimeDerivatives.size() - 1)) < ConfigurationParameters.AHP_REFRACTORY_PERIOD) {
			numeratorForTotalDerivative += c * totalTimeDerivatives.get(totalTimeDerivatives.size() - 1);
			denominatorForTotalDerivative += c;
		}

		double totalDiff = numeratorForTotalDerivative / denominatorForTotalDerivative;
		timeDifferentials[thisSpikeTimeIndex][thisKernelComponentIndex] = totalDiff;
		totalTimeDerivatives.add(totalDiff);
	}

	/**
	 * This method drives the computation of gradient descent w.r.t. each kernel
	 * coefficient
	 *
	 * @throws Exception
	 */
	public void calculateErrorDifferential() throws Exception {
		// commenting this out because we are no longer calculating the first term in
		// error differential
		/*
		 * double[][] alphaArray = new
		 * double[1][coefficientsOfReconstructedSignal.length]; alphaArray[0] =
		 * coefficientsOfReconstructedSignal;
		 */ errorGradients = new double[numberOfKernels][numberofKernelComponents];
		for (int i = 0; i < numberOfKernels; i++) {
			for (int j = 0; j < numberofKernelComponents; j++) {
				errorGradients[i][j] += calculateSecondTermInefficiently(i, j);
				errorGradients[i][j] += calculateThirdTermInefficiently(i, j);// calculateThirdTerm(i, j);
			}
		}
	}

	public double calculateThirdTerm(int kernelIndex, int componentIndex) throws Exception {
		double total = 0;
		for (int i = 0; i < spikeTimings.size(); i++) {
			if (kernelIndex == kernelIndexesForSpikes.get(i)) {
				double part = 0;
				// compute the first part
				for (int c = 0; c < numberofKernelComponents; c++) {
					double ti = spikeTimings.get(i);
					part += kernelMgr.kernelCoefficients[kernelIndex][c]
							* getSignalKernelDiffCompConvolution(kernelIndex, c, ti);
				}
				// compute the second part
				for (int k = 0; k < spikeTimings.size(); k++) {
					for (int c1 = 0; c1 < numberofKernelComponents; c1++) {
						for (int c2 = 0; c2 < numberofKernelComponents; c2++) {
							double alphak = coefficientsOfReconstructedSignal[k];
							int jk = kernelIndexesForSpikes.get(k);
							double betac1jk = kernelMgr.kernelCoefficients[jk][c1];
							double betac2ji = kernelMgr.kernelCoefficients[kernelIndex][c2];
							double tk = spikeTimings.get(k);
							double ti = spikeTimings.get(i);
							part -= alphak * betac1jk * betac2ji
									* kernelMgr.getCompByCompDiff(jk, kernelIndex, c1, c2, tk, ti);
						}
					}
				}
				part *= -(2 * coefficientsOfReconstructedSignal[i] * timeDifferentials[i][componentIndex]);
				total += part;
			}
		}
		return total;
	}

	/**
	 * This method computes the third term in error gradient in an inefficient way
	 * i.e. without referring to the cache
	 * 
	 * @param kernelIndex
	 * @param componentIndex
	 * @return
	 * @throws Exception
	 */
	public double calculateThirdTermInefficiently(int kernelIndex, int componentIndex) throws Exception {
		double realThirdTerm = 0;
		Signal invertedKernel = kernelMgr.getInvertedKernel(kernelIndex);
		/**
		 * the differential is multiplied with -1 because differential of k(-t) is
		 * -k'(-t)
		 */
		Signal diffInvertedKernel = SignalUtils.scalarMultiply(SignalUtils.calculateSignalDifferential(invertedKernel),
				-1);
		Signal errorSignal = SignalUtils.addTwoSignals(thisSignal,
				SignalUtils.scalarMultiply(getReconstructedSignal(), -1));
		for (int i = 0; i < spikeTimings.size(); i++) {
			if (kernelIndexesForSpikes.get(i) == kernelIndex) {
				Signal shiftedKernel = SignalUtils.shiftSignal(diffInvertedKernel, spikeTimings.get(i));
				realThirdTerm += -2 * coefficientsOfReconstructedSignal[i] * timeDifferentials[i][componentIndex]
						* SignalUtils
								.calculateSignalIntegral(SignalUtils.multiplyTwoSignals(errorSignal, shiftedKernel));
			}
		}
		return realThirdTerm;
	}

	/**
	 * This function evaluates the second term in the error gradient calculation
	 *
	 * @param kernelIndex
	 * @param componentIndex
	 * @return
	 * @throws Exception
	 */
	public double calculateSecondTerm(int kernelIndex, int componentIndex) throws Exception {
		double total = 0;
		for (int i = 0; i < spikeTimings.size(); i++) {
			if (kernelIndex == kernelIndexesForSpikes.get(i)) {
				double part = 0;
				part -= getSignalKernelCompConvolution(kernelIndex, componentIndex, spikeTimings.get(i));
				for (int k = 0; k < spikeTimings.size(); k++) {
					for (int c = 0; c < numberofKernelComponents; c++) {
						int jk = kernelIndexesForSpikes.get(k);
						part += coefficientsOfReconstructedSignal[k] * kernelMgr.kernelCoefficients[jk][c]
								* kernelMgr.getCompByCompMult(kernelIndex, jk, componentIndex, c, spikeTimings.get(i),
										spikeTimings.get(k));
					}
				}
				total += 2 * coefficientsOfReconstructedSignal[i] * part;
			}
		}
		return total;
	}

	/**
	 * This method computes the second term in error differential inefficiently i.e.
	 * without referring to the cached values
	 * 
	 * @param kernelIndex
	 * @param componentIndex
	 * @return
	 * @throws Exception
	 */
	public double calculateSecondTermInefficiently(int kernelIndex, int componentIndex) throws Exception {
		double realSecondTerm = 0;
		Signal comB = kernelMgr.getBasisForKernelComp(kernelIndex, 0);
		Signal errorSignal = SignalUtils.addTwoSignals(thisSignal,
				SignalUtils.scalarMultiply(getReconstructedSignal(), -1));
		for (int i = 0; i < spikeTimings.size(); i++) {
			if (kernelIndexesForSpikes.get(i) == kernelIndex) {
				double shift = spikeTimings.get(i) - kernelMgr.componentBsplineLengths[kernelIndex]
						- kernelMgr.componentBsplineShifts[kernelIndex][componentIndex];
				Signal shiftedDb = SignalUtils.shiftSignal(comB, shift);
				realSecondTerm += -2 * coefficientsOfReconstructedSignal[i]
						* SignalUtils.calculateSignalIntegral(SignalUtils.multiplyTwoSignals(errorSignal, shiftedDb));
			}
		}
		return realSecondTerm;
	}

	public Signal[] signalKernelComponentConvolutions;
	public Signal[] signalDifferentialKernelComponentConvolutions;

	/**
	 * This function initializes all the signal to kernel component convolutions
	 *
	 * @throws Exception
	 */
	private void initializeSignalToKernelCompConvolutions() throws Exception {
		signalDifferentialKernelComponentConvolutions = new Signal[numberOfKernels];
		signalKernelComponentConvolutions = new Signal[numberOfKernels];
		for (int i = 0; i < numberOfKernels; i++) {
			signalKernelComponentConvolutions[i] = populateKernelCompConvolution(i);
			signalDifferentialKernelComponentConvolutions[i] = populateKernelCompDiffConvolution(i);
		}
	}

	private Signal populateKernelCompConvolution(int kernelIndex) throws Exception {
		Signal kernelComponent = kernelMgr.getBasisForKernelComp(kernelIndex, 0);
		int kernelCompLength = (int) kernelComponent.getEndTime();
		double[] data = new double[thisSignal.getLength() + kernelCompLength];
		for (int i = 0; i < data.length; i++) {
			// Signal shiftedKernelComp = SignalUtils.shiftSignal(kernelComponent, i -
			// kernelLength);
			data[i] = kernelMgr.kernelCalc.calculateSignalKernelCompConvolution(thisSignal, kernelIndex,
					i - kernelCompLength);
			// SignalUtils.calculateAccurateConvolutionWithTimeStep(shiftedKernelComp,
			// thisSignal, ConfigurationParameters.TIME_STEP_FOR_CONVOLUTIONS);
			// bringing a more accurate version to calculate this convolution by
			// considering the timestep as well
			// SignalUtils.calculateSignalIntegral(SignalUtils.multiplyTwoSignals(shiftedKernelComp,
			// thisSignal));
		}
		return new Signal(data, 0, thisSignal.getLength() + kernelCompLength, 0);
	}

	private double getSignalKernelCompConvolution(int kernelIndex, int compIndex, double time) throws Exception {
		double del = kernelMgr.getBasisForKernelComp(kernelIndex, compIndex).getStartTime();
		return signalKernelComponentConvolutions[kernelIndex].getSignalValue(time - del);
	}

	private double getSignalKernelDiffCompConvolution(int kernelIndex, int compIndex, double time) throws Exception {
		double del = kernelMgr.getBasisForKernelComp(kernelIndex, compIndex).getStartTime();
		return -signalDifferentialKernelComponentConvolutions[kernelIndex].getSignalValue(time - del);
	}

	private Signal populateKernelCompDiffConvolution(int kernelIndex) throws Exception {
		// Signal givenSignal = thisSignal;
		Signal diffKernelComponent = kernelMgr.getDifferentialKernelComp(kernelIndex);
		int kernelCompLength = (int) diffKernelComponent.getEndTime();
		double[] data = new double[thisSignal.getLength() + kernelCompLength];
		for (int i = 0; i < data.length; i++) {
			data[i] = (signalKernelComponentConvolutions[kernelIndex].getSignalValue(i - kernelCompLength - 1)
					- signalKernelComponentConvolutions[kernelIndex].getSignalValue(i - kernelCompLength))
					/ ConfigurationParameters.TIME_STEP;
		}
		return new Signal(data, 0, thisSignal.getLength() + kernelCompLength, 0);
	}

	/**
	 * This function calculates the error due to reconstruction
	 *
	 * @return the error due to reconstruction
	 */
	public double calculateError() {
		double total = 0;
		total += SignalUtils.calculateSquaredNorm(thisSignal);
		for (int i = 0; i < spikeTimings.size(); i++) {
			total -= 2 * coefficientsOfReconstructedSignal[i]
					* signalKernelConvolutionCache[kernelIndexesForSpikes.get(i)].getSignalValue(spikeTimings.get(i));
			for (int k = 0; k < spikeTimings.size(); k++) {
				total += pMatrix[i][k] * coefficientsOfReconstructedSignal[i] * coefficientsOfReconstructedSignal[k];
			}
		}
		return total;
	}

	/**
	 * This method computes the error in signal reconstruction using the coeffs and
	 * thresholds
	 * 
	 * @return
	 */
	public double calculateErrorFast() {
		double error = signalNormSquare;
		if (spikeTimings.size() == 0) {
			return error;
		}
		for (int i = 0; i < coefficientsOfReconstructedSignal.length; i++) {
			try {
				error -= coefficientsOfReconstructedSignal[i] * convoledValues[0][i];
			} catch (Exception e) {
				// TODO: handle exception
				System.out.println("Check what's wrong here");
			}
		}
		return error;
	}

	/**
	 * This method computes the error in signal reconstruction using the coeffs and
	 * thresholds and using top N spikes
	 * 
	 * @return
	 */
	public double calculateErrorFastWithNSpikes() {
		double error = signalNormSquare;
		if (spikeTimings.size() == 0) {
			return error;
		}
		for (int i = 0; i < coefficientsOfReconstructedSignalWithNSpikes.length; i++) {
			try {
				error -= coefficientsOfReconstructedSignalWithNSpikes[i] * convolvedValuesWithNSpikes[0][i];
			} catch (Exception e) {
				// TODO: handle exception
				System.out.println("Check what's wrong here");
			}
		}
		return error;
	}

	/**
	 * This is the cache for the sqaured signal norm
	 */
	private double squaredNormOfSignal = -1;

	/**
	 * This function calculates the error due to reconstruction
	 *
	 * @return the error due to reconstruction
	 */
	public double calculateErrorRate() {
		double total = 0;
		double signalNormSquare = -1;
		if (ConfigurationParameters.IS_SIGNAL_CACHED && squaredNormOfSignal != -1) {
			signalNormSquare = squaredNormOfSignal;
		} else {
			signalNormSquare = SignalUtils.calculateSquaredNorm(thisSignal);
			squaredNormOfSignal = signalNormSquare;
		}
		total += signalNormSquare;
		if (total == 0) {
			return -1;
		}
		for (int i = 0; i < spikeTimings.size(); i++) {
			total -= 2 * coefficientsOfReconstructedSignal[i]
					* signalKernelConvolutionCache[kernelIndexesForSpikes.get(i)].getSignalValue(spikeTimings.get(i));
		}
		for (int i = 0; i < spikeTimings.size(); i++) {
			for (int k = 0; k < spikeTimings.size(); k++) {
				total += pMatrix[i][k] * coefficientsOfReconstructedSignal[i] * coefficientsOfReconstructedSignal[k];
			}
		}
		if (total < 0) {
			System.out.println("interesting");
		}
		return total / signalNormSquare;
	}
}