package sensoryCoding.network;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;

import org.ejml.simple.SimpleMatrix;

public class Network {
	// the given continuous time signal for which we are applying the gradient
	// descent
	public Signal thisSignal;
	// stores the differential of this signal
	public Signal differentialOfThisSignal;
	// the map that maps the spike timings to other properties
	// private Map<Integer, Integer> spikeIndexToKernelIndex = new HashMap<>();
	// this stores the list of kernel indexes generating the spikes in order
	public List<Integer> kernelIndexesForSpikes = new ArrayList<>();
	// the map that maps the spike timings to the corresponding threshold value
	// that generated the spike
	// private Map<Integer, Double> spikeTimeToThresholdValue = new HashMap<>();
	// The sequence of time values when a spike is generated
	public List<Double> spikeTimings;
	// matrix that stores the inner product of kernels
	public double[][] pMatrix = null; // [numberofSpikes][numberofSpikes] Pij
										// is the inner product of kernels the
										// produce ith and jth spikes
	// stores the inverse of the pMatrix
	public SimpleMatrix pInvMatrix = null;
	// this matrix stores the coefficients of the reconstructed signal
	public double[] coefficientsOfReconstructedSignal;
	// This matrix would store the differentials of spike timings wrt
	// coefficients of the kernels
	// i.e. (i,j)th entry denotes the differential of spike time ti w.r.t.
	// coefficient ki(b)j
	// which is the jth coeff. of kernel ki or the kernel generating ith spike
	public double timeDifferentials[][] = null;
	// This stores the reconstructed signal
	public Signal reconstructedSignal;
	// This stores the differentials of the coefficients of reconstructed signal
	// w.r.t. components of the kernels
	public double coefficientDifferentials[][][] = null;
	// This stores the gradient values w.r.t. each kernel component
	public double errorGradients[][] = null;
	// kernel manager responsible for generating and calculating the kernels
	// values
	public KernelManager kernelMgr = null;
	// denotes the number of kernels present in the network
	private int numberOfKernels;
	// denotes the number of components each kernel in the network has
	private int numberofKernelComponents;
	// stores the values of convolving the signal with the kernels stored a
	// column vector
	public SimpleMatrix convolvedValuesMatrix;
	// This indicates the time when the network is initialized
	private long startTime;
	// This stores the list of all spike times generated by the kernel
	public List<List<Double>> kernelSpikeTimes;
	// This stores the list of total derivatives of spike times generated by the
	// kernel
	private List<List<List<Double>>> kernelSpikeTimeTotalDerivatives;
	// This is the list of kernels selected for this particular network
	private List<Integer> selectedKernelIndexes = new ArrayList<>();

	public Signal[] signalKernelConvolutionCache;

	public double[] thresholdForTesting = new double[ConfigurationParameters.lengthOfComponentSignals];

	// rate at which the coefficients need to be updated
	public static double LEARNING_RATE = ConfigurationParameters.INITIAL_LEARNING_RATE;
	// this specifies the threshold value of the gradient vector length beyond
	// which we tune the gradient values
	public static double THRESHOLD_GRADIENT_STEP_LENGTH = ConfigurationParameters.INITIAL_THRESHOLD_GRADIENT_STEP_LENGTH;
	// This array stores the average spike rate for each kernel
	public int[] totalSpikeCount = new int[ConfigurationParameters.numberOfKernels];
	// This array stores the average coefficient of reconstruction for each kernel
	public double [] averageCoefficientOfReConstruction = new double[ConfigurationParameters.numberOfKernels];

	/**
	 *
	 * @param numberOfKernels
	 * @param numberofKernelComponents
	 * @throws Exception
	 */
	public Network(Signal signalPiece, int numberOfKernels, int numberofKernelComponents) throws Exception {
		startTime = System.currentTimeMillis();
		this.numberofKernelComponents = ConfigurationParameters.numberofKernelComponents;
		this.numberOfKernels = ConfigurationParameters.numberOfKernels;
		kernelMgr = new KernelManager(ConfigurationParameters.numberOfKernels,
				ConfigurationParameters.numberofKernelComponents, ConfigurationParameters.lengthOfComponentSignals);
		this.thisSignal = signalPiece;
		this.differentialOfThisSignal = SignalUtils.calculateSignalDifferential(thisSignal);
		initializeSignalToKernelCompConvolutions();
		selectAllKernels();
	}

	/**
	 * default constructor of the network
	 *
	 * @throws Exception
	 */
	public Network(Signal signalPiece) throws Exception {
		startTime = System.currentTimeMillis();
		this.numberofKernelComponents = ConfigurationParameters.numberofKernelComponents;
		this.numberOfKernels = ConfigurationParameters.numberOfKernels;
		kernelMgr = new KernelManager(ConfigurationParameters.numberOfKernels,
				ConfigurationParameters.numberofKernelComponents, ConfigurationParameters.lengthOfComponentSignals);
		this.thisSignal = signalPiece;
		selectAllKernels();
	}

	private void selectAllKernels() {
		// TODO Auto-generated method stub
		for (int i = 0; i < ConfigurationParameters.numberOfKernels; i++) {
			selectedKernelIndexes.add(i);
		}
	}

	/**
	 * default constructor of the network
	 *
	 * @throws Exception
	 */
	public Network(List<Integer> selectedKernels) throws Exception {
		this.numberofKernelComponents = ConfigurationParameters.numberofKernelComponents;
		this.numberOfKernels = ConfigurationParameters.numberOfKernels;
		kernelMgr = new KernelManager(ConfigurationParameters.numberOfKernels,
				ConfigurationParameters.numberofKernelComponents, ConfigurationParameters.lengthOfComponentSignals);
		this.selectedKernelIndexes = selectedKernels;
	}

	/**
	 * This method is invoked every time a new signal piece is injected
	 *
	 * @param signalPiece
	 * @throws Exception
	 */
	public void init(Signal signalPiece) throws Exception {
		init(signalPiece, true);
		/*
		 * // setting everything back to null this.coefficientDifferentials =
		 * null; this.coefficientsOfReconstructedSignal = null;
		 * this.convolvedValuesMatrix = null; this.differentialOfThisSignal =
		 * null; this.errorGradients = null; this.kernelIndexesForSpikes = new
		 * ArrayList<>(); this.signalDifferentialKernelComponentConvolutions =
		 * null; this.signalKernelComponentConvolutions = null;
		 * this.signalKernelConvolutionCache = null; this.spikeTimings = null;
		 * this.thisSignal = null; this.kernelSpikeTimes = new
		 * ArrayList<List<Double>>(); for(int i=0;
		 * i<ConfigurationParameters.numberOfKernels; i++){
		 * kernelSpikeTimes.add(new ArrayList<>()); } this.thisSignal =
		 * signalPiece; this.differentialOfThisSignal =
		 * SignalUtils.calculateSignalDifferential(thisSignal);
		 * initializeSignalToKernelCompConvolutions();
		 */
	}

	public void init(Signal signalPiece, boolean shouldUpdateSignalKernelCache) throws Exception {
		// TODO Auto-generated method stub
		// setting everything back to null
		this.coefficientDifferentials = null;
		this.coefficientsOfReconstructedSignal = null;
		this.convolvedValuesMatrix = null;
		this.errorGradients = null;
		this.kernelIndexesForSpikes = new ArrayList<>();
		this.signalKernelConvolutionCache = null;
		this.spikeTimings = null;
		this.thisSignal = null;
		this.kernelSpikeTimes = new ArrayList<List<Double>>();
		this.kernelSpikeTimeTotalDerivatives = new ArrayList<List<List<Double>>>();
		for (int i = 0; i < ConfigurationParameters.numberOfKernels; i++) {
			kernelSpikeTimes.add(new ArrayList<>());
			kernelSpikeTimeTotalDerivatives.add(new ArrayList<>());
			for (int c = 0; c < ConfigurationParameters.numberofKernelComponents; c++) {
				List<List<Double>> derivativeCompList = kernelSpikeTimeTotalDerivatives.get(i);
				derivativeCompList.add(new ArrayList<>());
			}
		}
		this.thisSignal = signalPiece;
		if (shouldUpdateSignalKernelCache) {
			this.differentialOfThisSignal = SignalUtils.calculateSignalDifferential(thisSignal);
			this.signalDifferentialKernelComponentConvolutions = null;
			this.signalKernelComponentConvolutions = null;
			initializeSignalToKernelCompConvolutions();
		}
	}

	/**
	 * This method needs to invoked whenever we are loading data from file
	 *
	 * @param signalPiece
	 * @param differentialSignal
	 * @param signalKernelComponentConvolutions
	 * @param signalDifferentialKernelComponentConvolutions
	 * @throws Exception
	 */
	public void initFromFileData(Signal signalPiece, Signal differentialSignal,
			Signal[] signalKernelComponentConvolutions, Signal[] signalDifferentialKernelComponentConvolutions)
			throws Exception {
		// setting everything back to null
		this.coefficientDifferentials = null;
		this.coefficientsOfReconstructedSignal = null;
		this.convolvedValuesMatrix = null;
		this.differentialOfThisSignal = null;
		this.errorGradients = null;
		this.kernelIndexesForSpikes = new ArrayList<>();
		this.signalDifferentialKernelComponentConvolutions = null;
		this.signalKernelComponentConvolutions = null;
		this.signalKernelConvolutionCache = null;
		this.spikeTimings = null;
		this.thisSignal = null;
		this.kernelSpikeTimes = new ArrayList<List<Double>>();
		this.kernelSpikeTimeTotalDerivatives = new ArrayList<>();
		for (int i = 0; i < ConfigurationParameters.numberOfKernels; i++) {
			kernelSpikeTimes.add(new ArrayList<>());
			kernelSpikeTimeTotalDerivatives.add(new ArrayList<>());
			for (int c = 0; c < ConfigurationParameters.numberofKernelComponents; c++) {
				List<List<Double>> derivativeCompList = kernelSpikeTimeTotalDerivatives.get(i);
				derivativeCompList.add(new ArrayList<>());
			}
		}
		this.thisSignal = signalPiece;
		this.differentialOfThisSignal = differentialSignal;
		this.signalKernelComponentConvolutions = signalKernelComponentConvolutions;
		this.signalDifferentialKernelComponentConvolutions = signalDifferentialKernelComponentConvolutions;
	}

	/**
	 * This method needs to invoked whenever we are loading data from file
	 *
	 * @param signalPiece
	 * @param differentialSignal
	 * @param signalKernelComponentConvolutions
	 * @param signalDifferentialKernelComponentConvolutions
	 * @throws Exception
	 */
	public void initFromFileData(Signal signalPiece, Signal differentialSignal,
			Signal[] signalKernelComponentConvolutions) throws Exception {
		// setting everything back to null
		this.coefficientDifferentials = null;
		this.coefficientsOfReconstructedSignal = null;
		this.convolvedValuesMatrix = null;
		this.differentialOfThisSignal = null;
		this.errorGradients = null;
		this.kernelIndexesForSpikes = new ArrayList<>();

		this.signalDifferentialKernelComponentConvolutions = null;
		this.signalKernelComponentConvolutions = null;
		this.signalKernelConvolutionCache = null;
		this.spikeTimings = null;
		this.thisSignal = null;
		this.kernelSpikeTimes = new ArrayList<List<Double>>();
		this.kernelSpikeTimeTotalDerivatives = new ArrayList<>();
		for (int i = 0; i < ConfigurationParameters.numberOfKernels; i++) {
			kernelSpikeTimes.add(new ArrayList<>());
			kernelSpikeTimeTotalDerivatives.add(new ArrayList<>());
			for (int c = 0; c < ConfigurationParameters.numberofKernelComponents; c++) {
				List<List<Double>> derivativeCompList = kernelSpikeTimeTotalDerivatives.get(i);
				derivativeCompList.add(new ArrayList<>());
			}
		}
		this.thisSignal = signalPiece;
		this.differentialOfThisSignal = differentialSignal;
		this.signalKernelComponentConvolutions = signalKernelComponentConvolutions;
		signalDifferentialKernelComponentConvolutions = new Signal[numberOfKernels];
		for (int i = 0; i < ConfigurationParameters.numberOfKernels; i++) {
			signalDifferentialKernelComponentConvolutions[i] = populateKernelCompDiffConvolution(i);
		}
	}

	/**
	 * This function returns the error gradient matrix
	 *
	 * @return
	 */
	public double[][] getErrorGradients() {
		return errorGradients;
	}

	/**
	 * This function updates the kernel coefficients
	 *
	 * @throws Exception
	 */
	public double updateKernelCoefficients() throws Exception {
		double[][] updateOnKernelCoeffs = new double[ConfigurationParameters.numberOfKernels][ConfigurationParameters.numberofKernelComponents];
		if (errorGradients == null || errorGradients.length == 0) {
			return -1;
		}
		double squaredLengthOfGardient = 0;
		for (int i = 0; i < numberOfKernels; i++) {
			for (int j = 0; j < numberofKernelComponents; j++) {
				squaredLengthOfGardient += Math.pow(errorGradients[i][j], 2);
			}
		}

		// check if the step length exceeds the threshold
		boolean flag = false;
		double gardientLength = Math.sqrt(squaredLengthOfGardient);
		if (LEARNING_RATE * gardientLength > THRESHOLD_GRADIENT_STEP_LENGTH) {
			flag = true;
		}

		// calculate the coefficient update
		for (int i = 0; i < numberOfKernels; i++) {
			for (int j = 0; j < numberofKernelComponents; j++) {
				double increment = -LEARNING_RATE * errorGradients[i][j];
				if (flag) {
					increment = -(THRESHOLD_GRADIENT_STEP_LENGTH / gardientLength) * errorGradients[i][j];
				}
				updateOnKernelCoeffs[i][j] = increment;
			}
		}
		// current error rate
		double currentErrorRate = calculateErrorRate();
		System.out.println("error rate:" + currentErrorRate);
		kernelMgr.incrementKernelCoefficient(updateOnKernelCoeffs);

		// if the fail-safe mode is on check the validity of the update
		if (ConfigurationParameters.FAIL_SAFE_ON) {
			init(thisSignal, false);
			calculateSpikeTimesAndReconstructSignal();
			double nextError = calculateErrorRate();
			System.out.println("error in this step:" + currentErrorRate + "next error will be:" + nextError);
			if (currentErrorRate <= nextError) {
				// decrease all learning rates and stuff
				kernelMgr.rollBackUpdate(updateOnKernelCoeffs);
				if (ConfigurationParameters.LOCAL_MINIMA_MODE) {
					lowerLearningRates();
				}
				// kick out of local minima
				else {
					double[][] presentKernelCoeffs = kernelMgr.kernelCoefficients;
					for (int i = 0; i < ConfigurationParameters.NUMBER_OF_KICKS; i++) {
						double[][] newkernelCoeffs = new double[ConfigurationParameters.numberOfKernels][ConfigurationParameters.numberofKernelComponents];
						for (int k = 0; k < ConfigurationParameters.numberOfKernels; k++) {
							for (int c = 0; c < ConfigurationParameters.numberofKernelComponents; c++) {
								newkernelCoeffs[k][c] = presentKernelCoeffs[k][c] * (2 * Math.random() - 1);
							}
						}
						kernelMgr.initKernelCoefficients(newkernelCoeffs);
						init(thisSignal, false);
						calculateSpikeTimesAndReconstructSignal();
						if (currentErrorRate >= calculateErrorRate()) {
							System.out.println("got a kick here");
							break;
						} else {
							kernelMgr.initKernelCoefficients(presentKernelCoeffs);
						}
					}
				}
			} /*
				 * else{ // bring back original learning rates
				 * restoreLearningRates(); }
				 */
		}
		return currentErrorRate;
	}

	/**
	 * Lower the learning rates
	 */
	private void lowerLearningRates() {
		// TODO Auto-generated method stub
		THRESHOLD_GRADIENT_STEP_LENGTH /= 10;
		LEARNING_RATE /= 10;
	}

	/**
	 * Increase the learning rate to kick out of the local minima
	 */
	private void increaseLearningRates() {
		THRESHOLD_GRADIENT_STEP_LENGTH *= 10;
		LEARNING_RATE *= 10;
	}

	/**
	 * bring back the original learning rates
	 */
	private void restoreLearningRates() {
		THRESHOLD_GRADIENT_STEP_LENGTH = ConfigurationParameters.INITIAL_THRESHOLD_GRADIENT_STEP_LENGTH;
		LEARNING_RATE *= ConfigurationParameters.INITIAL_LEARNING_RATE;
	}

	/**
	 * This function is used to update any statistics that we are interested in
	 * collecting from the network
	 *
	 * @param stepNumber
	 */
	public void UpdateStatistics(int stepNumber) {
		reconstructedSignal.saveSignalIntoFile("Reconstructed Signal after" + stepNumber + "steps",
				ConfigurationParameters.SIGNAL_IMAGE_FILE_NAME + stepNumber + ".png");
		Utilities.writeMatrixToFile("Error gradients after" + stepNumber + "steps",
				ConfigurationParameters.ERRORGRAD_LOG_FILE_NAME + stepNumber, errorGradients);
		Utilities.writeMatrixToFile("Kernel Coefficients after" + stepNumber + "steps",
				ConfigurationParameters.KERNELCOEFF_LOG_FILE_NAME + stepNumber, kernelMgr.kernelCoefficients);
		System.out.println("Time taken to till" + stepNumber + "steps:" + (System.currentTimeMillis() - startTime));
		System.out.println("The spike timings are as follows");
		for (int i = 0; i < spikeTimings.size(); i++) {
			System.out.print(spikeTimings.get(i));
			System.out.print(",");
		}
		System.out.println("Error due to reconstruction: " + calculateError());
		System.out.println("updated coefficient: " + kernelMgr.kernelCoefficients[0][0]);
	}

	/**
	 * This method saves the current state of the network into a file
	 *
	 * @param stepNumber
	 * @throws IOException
	 */
	public void saveNetworkState(int stepNumber) throws IOException {
		FileWriter fw = new FileWriter(ConfigurationParameters.STATE_OF_NETWORK);
		BufferedWriter bw = new BufferedWriter(fw);
		bw.write(Integer.toString(stepNumber));
		bw.write("\n");
		Utilities.writeMatrixToBufferedWriter(bw, kernelMgr.kernelCoefficients);
		bw.close();
	}

	/**
	 * This method retrieves the last state of the network from a file and
	 * returns the number of already executed steps
	 *
	 * @return
	 * @throws NumberFormatException
	 * @throws IOException
	 */
	public int restoreNetworkState() throws NumberFormatException, IOException {
		FileReader fr = new FileReader(ConfigurationParameters.STATE_OF_NETWORK);
		BufferedReader br = new BufferedReader(fr);
		int stepNumber = Integer.parseInt(br.readLine());
		double[][] kernelCoefficients = Utilities.readMatrixToBufferedWriter(br);
		br.close();
		kernelMgr.kernelCoefficients = kernelCoefficients;
		return stepNumber;
	}

	/**
	 * This method computes the reconstructed signal and runs a single step
	 * gradient descent on the coefficients of the kernels
	 *
	 * @throws Exception
	 */
	public void reconstructAndUpdateKernels() throws Exception {

		this.calculateSpikeTimings();
		// if there is no spike generated just get out of the method
		if (this.spikeTimings.size() == 0) {
			return;
		}
		this.calculatePMatrix(); // well tested
		this.calculateTheCoefficientsOfReconstructedKernel(); // well tested
	}

	/**
	 * This method computes the gradient wrt kernel coefficients
	 *
	 * @throws Exception
	 */
	public void calculateErrorGradient() throws Exception {
		// if there is no spike generated just get out of the method
		if (this.spikeTimings.size() == 0) {
			return;
		}
		long t1 = System.currentTimeMillis();
		// TODO: check this
		this.calculateTimeDifferentials();
		long t2 = System.currentTimeMillis();
		if (ConfigurationParameters.USER_MODE.equals(MODE.DEBUG_MODE))
			System.out.println("time to calculate time differentials:" + (t2 - t1) + "ms");
		this.calculateErrorDifferential();
		long t4 = System.currentTimeMillis();
		if (ConfigurationParameters.USER_MODE.equals(MODE.DEBUG_MODE))
			System.out.println("time to calculate error gradients:" + (t4 - t2) + "ms");
	}

	/**
	 * This method calculates the spike times and returns the reconstructed
	 * signal
	 *
	 * @return
	 * @throws Exception
	 */
	public void calculateSpikeTimesAndReconstructSignal() throws Exception {
		calculateSpikeTimings();
		// if there is no spike generated just get out of the method
		if (this.spikeTimings.size() == 0) {
			return;
		}
		System.out.println("number of generated spikes:" + spikeTimings.size());
		reconstructSignal();
	}
	
	@Deprecated
	/**
	 * a stopgap solution added for dealing with reconstruction ignoring certain spikes
	 */
	public void removeSpikes(List<Integer> indexestoBeRemoved) {
		double[][] newConvolvedValues = new double[1][spikeTimings.size() - indexestoBeRemoved.size()];
		int newArrayIndex = newConvolvedValues[0].length - 1;
		for (int i = spikeTimings.size() - 1; i >= 0; i--) {
			if (indexestoBeRemoved.contains(i)) {
				spikeTimings.remove(i);
				kernelIndexesForSpikes.remove(i);
			} else {
				// populate the threshold matrix
				newConvolvedValues[0][newArrayIndex] = convoledValues[0][i];
				newArrayIndex--;
			}
		}
		convolvedValuesMatrix = new SimpleMatrix(newConvolvedValues).transpose();
	}
	
	/**
	 * Given the spike times reconstruct the signal
	 * @throws Exception
	 */
	public void reconstructSignal() throws Exception {
		calculatePMatrix();
		calculateTheCoefficientsOfReconstructedKernel();
		if(ConfigurationParameters.SHOULD_COLLECT_SPIKE_STATISTICS){
			populateSpikeStatistics();
		}
	}
	private void populateSpikeStatistics() {
		// TODO Auto-generated method stub
		double [] sumOfCoefficientsOfReconstructedKernel = new double[ConfigurationParameters.numberOfKernels];
		for(int i=0; i<coefficientsOfReconstructedSignal.length; i++){
			int kernelIndex = kernelIndexesForSpikes.get(i);
			double coeff = coefficientsOfReconstructedSignal[i];
			sumOfCoefficientsOfReconstructedKernel[kernelIndex]+=coeff;
		}

		for (int i = 0; i < ConfigurationParameters.numberOfKernels; i++) {
			int initialSpikeCount = totalSpikeCount[i];
			int updatedSpikeCount = initialSpikeCount + kernelSpikeTimes.get(i).size();
			if (updatedSpikeCount != 0) {
				averageCoefficientOfReConstruction[i] = (averageCoefficientOfReConstruction[i] * initialSpikeCount
						+ sumOfCoefficientsOfReconstructedKernel[i]) / updatedSpikeCount;
			}
			totalSpikeCount[i] = updatedSpikeCount;
		}
	}

	/**
	 * Gets the indexes of all the spikes generated by this kernel
	 *
	 * @return
	 */
	public List<Integer> GetAllSpikesGeneratedByThisKernel(int kernelIndex) {
		List<Integer> generatedSpikeIndexes = new ArrayList<>();
		for (int i = 0; i < spikeTimings.size(); i++) {
			if (kernelIndexesForSpikes.get(i).equals(kernelIndex)) {
				generatedSpikeIndexes.add(i);
			}
		}
		return generatedSpikeIndexes;
	}

	/**
	 * This method returns the reconstructed signal from the input signal
	 *
	 * @return
	 * @throws Exception
	 */
	public Signal getReconstructedSignal() throws Exception {
		kernelMgr.loadTimeInvertedKernelCache();
		Signal resultingReconstruction = new Signal(new double[thisSignal.getLength()], 0, 0);
		for (int i = 0; i < spikeTimings.size(); i++) {
			resultingReconstruction = SignalUtils.addTwoSignals(resultingReconstruction,
					SignalUtils.scalarMultiply(
							SignalUtils.shiftSignal(kernelMgr.getInvertedKernel(kernelIndexesForSpikes.get(i)),
									spikeTimings.get(i)),
							coefficientsOfReconstructedSignal[i]));
		}
		this.reconstructedSignal = resultingReconstruction;
		return this.reconstructedSignal;
	}

	/**
	 * This method computes the coefficients of the reconstructed kernel
	 */
	private void calculateTheCoefficientsOfReconstructedKernel() {
		coefficientsOfReconstructedSignal = new double[spikeTimings.size()];
		coefficientsOfReconstructedSignal = Utilities
				.getArrayFromMatrix((pInvMatrix.mult(convolvedValuesMatrix)).transpose())[0];
	}

	/**
	 * This method calculates the P matrix or the kernel product matrix
	 *
	 * @throws Exception
	 */
	private void calculatePMatrix() throws Exception {
		// TODO Auto-generated method stub
		pMatrix = new double[spikeTimings.size()][spikeTimings.size()];
		for (int i = 0; i < spikeTimings.size(); i++) {
			for (int j = 0; j < spikeTimings.size(); j++) {
				pMatrix[i][j] = calculatePij(i, j);
			}
		}
		pInvMatrix = new SimpleMatrix(pMatrix).invert();

	}

	// Verified
	/**
	 * This method calculates each entry in the PMatrix
	 *
	 * @param i
	 * @param j
	 * @return
	 * @throws Exception
	 */
	private double calculatePij(int i, int j) throws Exception {
		int kernelIndexI = kernelIndexesForSpikes.get(i);
		int kernelIndexJ = kernelIndexesForSpikes.get(j);
		double timeShiftOfI = spikeTimings.get(i);
		double timeShiftOfJ = spikeTimings.get(j);
		double total = 0;
		for (int c1 = 0; c1 < numberofKernelComponents; c1++) {
			double betac1 = kernelMgr.kernelCoefficients[kernelIndexI][c1];
			for (int c2 = 0; c2 < numberofKernelComponents; c2++) {
				double betac2 = kernelMgr.kernelCoefficients[kernelIndexJ][c2];
				total += betac1 * betac2
						* kernelMgr.getCompByCompMult(kernelIndexI, kernelIndexJ, c1, c2, timeShiftOfI, timeShiftOfJ);
			}
		}
		return total;
	}

	/**
	 * This method computes the spike timings
	 *
	 * @throws Exception
	 */
	private void calculateSpikeTimings() throws Exception {
		signalKernelConvolutionCache = new Signal[numberOfKernels];
		List<SpikeTimeIndexAndConvolvedValues> spikeTimes = new ArrayList<>();
		for (int kernelIndexer = 0; kernelIndexer < selectedKernelIndexes.size(); kernelIndexer++) {
			// for (int i = 0; i < numberOfKernels; i++) {
			int i = selectedKernelIndexes.get(kernelIndexer);
			double[] convolvedSignal = new double[thisSignal.getLength()];
			for (int j = 0; j < thisSignal.getLength(); j++)
				for (int k = 0; k < numberofKernelComponents; k++) {
					convolvedSignal[j] += kernelMgr.kernelCoefficients[i][k] * getSignalKernelCompConvolution(i, k, j);
				}
			signalKernelConvolutionCache[i] = new Signal(convolvedSignal);
			List<SpikeTimeIndexAndConvolvedValues> allSpikes = generateSpikes(convolvedSignal, i);
			spikeTimes.addAll(allSpikes);
		}

		spikeTimes.sort(new Comparator<SpikeTimeIndexAndConvolvedValues>() {

			@Override
			public int compare(SpikeTimeIndexAndConvolvedValues o1, SpikeTimeIndexAndConvolvedValues o2) {
				if (o1.spikeTime == o2.spikeTime) {
					return 0;
				} else if (o1.spikeTime < o2.spikeTime) {
					return -1;
				}
				return 1;
			}
		});
		this.spikeTimings = new ArrayList<>();
		// this.spikeIndexToKernelIndex = new HashMap<>();
		convoledValues = new double[1][spikeTimes.size()];
		for (int i = 0; i < spikeTimes.size(); i++) {
			SpikeTimeIndexAndConvolvedValues thisSpike = spikeTimes.get(i);
			spikeTimings.add(thisSpike.spikeTime);
			convoledValues[0][i] = thisSpike.convolvedValue;
			// spikeIndexToKernelIndex.put(i, thisSpike.kernelIndex);
			kernelIndexesForSpikes.add(thisSpike.kernelIndex);
		}
		
		convolvedValuesMatrix = new SimpleMatrix(convoledValues).transpose();
	}
	
	private double[][] convoledValues;
	/**
	 *
	 * @param convolvedSignal
	 * @param kernelIndex
	 * @return
	 */
	private List<SpikeTimeIndexAndConvolvedValues> generateSpikes(double[] convolvedSignal, int kernelIndex) {
		List<SpikeTimeIndexAndConvolvedValues> generatedSpikes = new ArrayList<>();
		// TODO: at t=0 we are not generating any spikes
		for (int l = 1; l < convolvedSignal.length; l++) {
			double threshold = getThreshold(kernelIndex, l);
			if (convolvedSignal[l] > threshold) {
				double deltaThreshold = getThreshold(kernelIndex, l) - getThreshold(kernelIndex, l - 1);
				double deltaSignal = convolvedSignal[l] - convolvedSignal[l - 1];
				double deltaTime = (getThreshold(kernelIndex, l - 1) - convolvedSignal[l - 1])
						/ (deltaSignal - deltaThreshold);
				if (deltaTime > 1 || deltaTime < 0) {
					throw new IllegalArgumentException("delta time has invalid value:" + deltaTime);
				}
				double thisSpikeTime = (l - 1 + deltaTime) * ((double) ConfigurationParameters.TIME_STEP);
				generatedSpikes.add(new SpikeTimeIndexAndConvolvedValues(thisSpikeTime, kernelIndex, threshold));
				List<Double> spikeTimes = kernelSpikeTimes.get(kernelIndex);
				spikeTimes.add(thisSpikeTime);
			}
			thresholdForTesting[l] = threshold;
		}
		return generatedSpikes;
	}

	/**
	 * This method returns the threshold value for a given kernel at a
	 * particular time instance
	 *
	 * @param kernelIndex
	 * @param time
	 * @return
	 */
	private double getThreshold(int kernelIndex, int time) {
		return kernelMgr.getThreshold(kernelIndex, time) + getAhpForThisKernel(kernelIndex, time);
	}

	private double getAhpForThisKernel(int kernelIndex, int time) {
		// TODO Auto-generated method stub
		List<Double> thisKernelSpikes = kernelSpikeTimes.get(kernelIndex);
		double total = 0;
		for (int i = thisKernelSpikes.size() - 1; i >= 0; i--) {
			total += (ConfigurationParameters.AHP_CONSTANT)
					* Math.exp(-(time - thisKernelSpikes.get(i)) / ConfigurationParameters.TIME_CONSTANT);
		}
		return total;
	}

	/**
	 * This function returns the differential of the ahp function
	 *
	 * @param timeDiff
	 * @return
	 */
	private double getAhpDifferential(double timeDiff) {
		return -ConfigurationParameters.AHP_CONSTANT * (Math.exp(-(timeDiff / ConfigurationParameters.TIME_CONSTANT))
				/ ConfigurationParameters.TIME_CONSTANT);
	}

	/**
	 * This method computes the differentials of the spike times wrt kernel
	 * coefficients
	 *
	 * @throws Exception
	 */
	private void calculateTimeDifferentials() throws Exception {
		timeDifferentials = new double[spikeTimings.size()][numberofKernelComponents];
		for (int i = 0; i < timeDifferentials.length; i++) {
			for (int j = 0; j < numberofKernelComponents; j++) {
				calculateSingleTimeDifferential(i, j);
			}
		}
	}

	/*************************************/
	/******** impl1 commented out **********/
	/*************************************/
	/*	*//**
			 * This method calculates the differential of the ith spike timing
			 * w.r.t. jth coeff. of the kernel generating the spike
			 *
			 * @param thisSpikeTimeIndex
			 * @param thisKernelComponentIndex
			 * @throws Exception
			 *//*
			 * private void calculateSingleTimeDifferential(int
			 * thisSpikeTimeIndex, int thisKernelComponentIndex) throws
			 * Exception { if(thisSpikeTimeIndex == 13){
			 * System.out.println("come here"); } double spikeTime =
			 * spikeTimings.get(thisSpikeTimeIndex); int thisKernelIndex =
			 * kernelIndexesForSpikes.get(thisSpikeTimeIndex); // TODO: this can
			 * be improved in performance // calculate the numerator double
			 * numerator = -getSignalKernelCompConvolution(thisKernelIndex,
			 * thisKernelComponentIndex, spikeTime); double denominator =
			 * (signalKernelConvolutionCache[thisKernelIndex].getSignalValue(
			 * spikeTime + 1) -
			 * signalKernelConvolutionCache[thisKernelIndex].getSignalValue(
			 * spikeTime)) / ConfigurationParameters.TIME_STEP;
			 *
			 * double denominatorForParital = denominator; List<Double>
			 * totalTimeDerivatives =
			 * kernelSpikeTimeTotalDerivatives.get(thisKernelIndex).get(
			 * thisKernelComponentIndex); List<Double> thisKernelSpikeTimes =
			 * kernelSpikeTimes.get(thisKernelIndex); for(int i=
			 * totalTimeDerivatives.size()-1; i>=0; i--){ denominatorForParital
			 * -= getAhpDifferential(spikeTime- thisKernelSpikeTimes.get(i)); }
			 *
			 * double partialTimeDiff = numerator/denominatorForParital;
			 *
			 * double totalTimeDiff = partialTimeDiff; for(int i=
			 * totalTimeDerivatives.size()-1; i>=0; i--){ double
			 * partialTimeDiffForThisPrevSpike = (-
			 * getAhpDifferential(spikeTime-
			 * thisKernelSpikeTimes.get(i)))/(denominator); totalTimeDiff +=
			 * totalTimeDerivatives.get(i)*partialTimeDiffForThisPrevSpike; }
			 *
			 * timeDifferentials[thisSpikeTimeIndex][thisKernelComponentIndex] =
			 * totalTimeDiff; totalTimeDerivatives.add(totalTimeDiff); }
			 */

	/*************************************/
	/******** impl2 in use for now *********/
	/*************************************/
	private void calculateSingleTimeDifferential(int thisSpikeTimeIndex, int thisKernelComponentIndex)
			throws Exception {
		double spikeTime = spikeTimings.get(thisSpikeTimeIndex);
		int thisKernelIndex = kernelIndexesForSpikes.get(thisSpikeTimeIndex);
		// TODO: this can be improved in performance
		// calculate the numerator
		double numerator = -getSignalKernelCompConvolution(thisKernelIndex, thisKernelComponentIndex, spikeTime);
		double denominator = (signalKernelConvolutionCache[thisKernelIndex].getSignalValue(spikeTime + 1)
				- signalKernelConvolutionCache[thisKernelIndex].getSignalValue(spikeTime))
				/ ConfigurationParameters.TIME_STEP;

		double denominatorForTotalDerivative = denominator;
		double numeratorForTotalDerivative = numerator;
		List<Double> totalTimeDerivatives = kernelSpikeTimeTotalDerivatives.get(thisKernelIndex)
				.get(thisKernelComponentIndex);
		List<Double> thisKernelSpikeTimes = kernelSpikeTimes.get(thisKernelIndex);
		for (int i = totalTimeDerivatives.size() - 1; i >= 0; i--) {
			denominatorForTotalDerivative -= getAhpDifferential(spikeTime - thisKernelSpikeTimes.get(i));
			numeratorForTotalDerivative -= getAhpDifferential(spikeTime - thisKernelSpikeTimes.get(i))
					* totalTimeDerivatives.get(i);
		}
		double totalDiff = numeratorForTotalDerivative / denominatorForTotalDerivative;
		timeDifferentials[thisSpikeTimeIndex][thisKernelComponentIndex] = totalDiff;
		totalTimeDerivatives.add(totalDiff);
	}

	/**
	 * This method drives the computation of gradient descent w.r.t. each kernel
	 * coefficient
	 *
	 * @throws Exception
	 */
	private void calculateErrorDifferential() throws Exception {
		double[][] alphaArray = new double[1][coefficientsOfReconstructedSignal.length];
		alphaArray[0] = coefficientsOfReconstructedSignal;
		errorGradients = new double[numberOfKernels][numberofKernelComponents];
		for (int i = 0; i < numberOfKernels; i++) {
			for (int j = 0; j < numberofKernelComponents; j++) {
				errorGradients[i][j] += calculateSecondTerm(i, j);
				errorGradients[i][j] += calculateThirdTerm(i, j);
			}
		}
	}

	private double calculateThirdTerm(int kernelIndex, int componentIndex) throws Exception {
		double total = 0;
		for (int i = 0; i < spikeTimings.size(); i++) {
			if (kernelIndex == kernelIndexesForSpikes.get(i)) {
				double part = 0;
				// compute the first part
				for (int c = 0; c < numberofKernelComponents; c++) {
					double ti = spikeTimings.get(i);
					part -= kernelMgr.kernelCoefficients[kernelIndex][c]
							* getSignalKernelDiffCompConvolution(kernelIndex, c, ti);
				}
				// compute the second part
				for (int k = 0; k < spikeTimings.size(); k++) {
					for (int c1 = 0; c1 < numberofKernelComponents; c1++) {
						for (int c2 = 0; c2 < numberofKernelComponents; c2++) {
							double alphak = coefficientsOfReconstructedSignal[k];
							int jk = kernelIndexesForSpikes.get(k);
							double betac1jk = kernelMgr.kernelCoefficients[jk][c1];
							double betac2ji = kernelMgr.kernelCoefficients[kernelIndex][c2];
							double tk = spikeTimings.get(k);
							double ti = spikeTimings.get(i);
							part += alphak * betac1jk * betac2ji
									* kernelMgr.getCompByCompDiff(jk, kernelIndex, c1, c2, tk, ti);
						}
					}
				}
				part *= (2 * coefficientsOfReconstructedSignal[i] * timeDifferentials[i][componentIndex]);
				total += part;
			}
		}
		return total;
	}

	/**
	 * This function evaluates the second term in the error gradient calculation
	 *
	 * @param kernelIndex
	 * @param componentIndex
	 * @return
	 * @throws Exception
	 */
	private double calculateSecondTerm(int kernelIndex, int componentIndex) throws Exception {
		double total = 0;
		for (int i = 0; i < spikeTimings.size(); i++) {
			if (kernelIndex == kernelIndexesForSpikes.get(i)) {
				double part = 0;
				part -= getSignalKernelCompConvolution(kernelIndex, componentIndex, spikeTimings.get(i));
				for (int k = 0; k < spikeTimings.size(); k++) {
					for (int c = 0; c < numberofKernelComponents; c++) {
						int jk = kernelIndexesForSpikes.get(k);
						part += coefficientsOfReconstructedSignal[k] * kernelMgr.kernelCoefficients[jk][c]
								* kernelMgr.getCompByCompMult(kernelIndex, jk, componentIndex, c, spikeTimings.get(i),
										spikeTimings.get(k));
					}
				}
				total += 2 * coefficientsOfReconstructedSignal[i] * part;
			}
		}
		return total;
	}

	public Signal[] signalKernelComponentConvolutions;
	public Signal[] signalDifferentialKernelComponentConvolutions;

	/**
	 * This function initializes all the signal to kernel component convolutions
	 *
	 * @throws Exception
	 */
	private void initializeSignalToKernelCompConvolutions() throws Exception {
		signalDifferentialKernelComponentConvolutions = new Signal[numberOfKernels];
		signalKernelComponentConvolutions = new Signal[numberOfKernels];
		for (int i = 0; i < numberOfKernels; i++) {
			signalKernelComponentConvolutions[i] = populateKernelCompConvolution(i);
			signalDifferentialKernelComponentConvolutions[i] = populateKernelCompDiffConvolution(i);
		}
	}

	private Signal populateKernelCompConvolution(int kernelIndex) throws Exception {
		Signal kernelComponent = kernelMgr.getBasisForKernelComp(kernelIndex, 0);
		int kernelLength = (int) kernelComponent.getEndTime();
		double[] data = new double[thisSignal.getLength() + kernelLength];
		for (int i = 0; i < data.length; i++) {
			// Signal shiftedKernelComp = SignalUtils.shiftSignal(kernelComponent, i - kernelLength);
			data[i] = kernelMgr.kernelCalc.calculateSignalKernelCompConvolution(thisSignal, kernelIndex, i-kernelLength);
			// SignalUtils.calculateAccurateConvolutionWithTimeStep(shiftedKernelComp,
			// thisSignal, ConfigurationParameters.TIME_STEP_FOR_CONVOLUTIONS);
			// bringing a more accurate version to calculate this convolution by
			// considering the timestep as well
			// SignalUtils.calculateSignalIntegral(SignalUtils.multiplyTwoSignals(shiftedKernelComp,
			// thisSignal));
		}
		return new Signal(data, -kernelLength, thisSignal.getLength(), -kernelLength);
	}

	private double getSignalKernelCompConvolution(int kernelIndex, int compIndex, double time) throws Exception {
		double del = kernelMgr.getBasisForKernelComp(kernelIndex, compIndex).getEndTime();
		return signalKernelComponentConvolutions[kernelIndex].getSignalValue(time - del);
	}

	private double getSignalKernelDiffCompConvolution(int kernelIndex, int compIndex, double time) throws Exception {
		double del = kernelMgr.getBasisForKernelComp(kernelIndex, compIndex).getEndTime();
		return -signalDifferentialKernelComponentConvolutions[kernelIndex].getSignalValue(time - del);
	}

	private Signal populateKernelCompDiffConvolution(int kernelIndex) throws Exception {
		// Signal givenSignal = thisSignal;
		Signal diffKernelComponent = kernelMgr.getDifferentialKernelComp(kernelIndex);
		int kernelLength = (int) diffKernelComponent.getEndTime();
		double[] data = new double[thisSignal.getLength() + kernelLength];
		for (int i = 0; i < data.length; i++) {
			data[i] = (signalKernelComponentConvolutions[kernelIndex].getSignalValue(i - kernelLength - 1)
					- signalKernelComponentConvolutions[kernelIndex].getSignalValue(i - kernelLength))
					/ ConfigurationParameters.TIME_STEP;
		}
		return new Signal(data, -kernelLength, thisSignal.getLength(), -kernelLength);
	}

	/**
	 * This function calculates the error due to reconstruction
	 *
	 * @return the error due to reconstruction
	 */
	public double calculateError() {
		double total = 0;
		total += SignalUtils.calculateSquaredNorm(thisSignal);
		for (int i = 0; i < spikeTimings.size(); i++) {
			total -= 2 * coefficientsOfReconstructedSignal[i]
					* signalKernelConvolutionCache[kernelIndexesForSpikes.get(i)].getSignalValue(spikeTimings.get(i));
			for (int k = 0; k < spikeTimings.size(); k++) {
				total += pMatrix[i][k] * coefficientsOfReconstructedSignal[i] * coefficientsOfReconstructedSignal[k];
			}
		}
		return total;
	}

	/**
	 * This is the cache for the sqaured signal norm
	 */
	private double squaredNormOfSignal = -1;

	/**
	 * This function calculates the error due to reconstruction
	 *
	 * @return the error due to reconstruction
	 */
	public double calculateErrorRate() {
		double total = 0;
		double signalNormSquare = -1;
		if (ConfigurationParameters.IS_SIGNAL_CACHED && squaredNormOfSignal != -1) {
			signalNormSquare = squaredNormOfSignal;
		} else {
			signalNormSquare = SignalUtils.calculateSquaredNorm(thisSignal);
			squaredNormOfSignal = signalNormSquare;
		}
		total += signalNormSquare;
		if (total == 0) {
			return -1;
		}
		for (int i = 0; i < spikeTimings.size(); i++) {
			total -= 2 * coefficientsOfReconstructedSignal[i]
					* signalKernelConvolutionCache[kernelIndexesForSpikes.get(i)].getSignalValue(spikeTimings.get(i));
		}
		for (int i = 0; i < spikeTimings.size(); i++) {
			for (int k = 0; k < spikeTimings.size(); k++) {
				total += pMatrix[i][k] * coefficientsOfReconstructedSignal[i] * coefficientsOfReconstructedSignal[k];
			}
		}
		if (total < 0) {
			System.out.println("interesting");
		}
		return total / signalNormSquare;
	}
}